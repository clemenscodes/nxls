{"version":3,"file":"main.js","mappings":"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","sources":["webpack://nxls/webpack/runtime/create fake namespace object","webpack://nxls/../../libs/shared/npm/src/lib/ sync","webpack://nxls/../../libs/language-server/workspace/src/lib/ sync","webpack://nxls/../../libs/language-server/workspace/src/lib/ lazy namespace object","webpack://nxls/external commonjs \"nx/src/native\"","webpack://nxls/webpack/bootstrap","webpack://nxls/webpack/runtime/compat get default export","webpack://nxls/webpack/runtime/define property getters","webpack://nxls/webpack/runtime/hasOwnProperty shorthand","webpack://nxls/webpack/runtime/make namespace object","webpack://nxls/external commonjs \"core-js/modules/es.promise.js\"","webpack://nxls/external commonjs \"core-js/modules/es.regexp.to-string.js\"","webpack://nxls/external commonjs \"core-js/modules/es.string.ends-with.js\"","webpack://nxls/external commonjs \"core-js/modules/es.array.iterator.js\"","webpack://nxls/external commonjs \"core-js/modules/web.dom-collections.iterator.js\"","webpack://nxls/../../libs/language-server/utils/src/lib/lsp-log.ts","webpack://nxls/external commonjs \"vscode-json-languageservice\"","webpack://nxls/../../libs/language-server/utils/src/lib/json-language-service.ts","webpack://nxls/external commonjs \"request-light\"","webpack://nxls/external commonjs \"vscode-uri\"","webpack://nxls/external node-commonjs \"fs\"","webpack://nxls/../../libs/language-server/utils/src/lib/runtime.ts","webpack://nxls/external commonjs \"core-js/modules/es.array.sort.js\"","webpack://nxls/external commonjs \"core-js/modules/es.object.from-entries.js\"","webpack://nxls/external commonjs \"core-js/modules/es.regexp.constructor.js\"","webpack://nxls/external commonjs \"core-js/modules/es.regexp.exec.js\"","webpack://nxls/external commonjs \"core-js/modules/es.string.replace.js\"","webpack://nxls/../../libs/shared/utils/src/lib/utils.ts","webpack://nxls/external node-commonjs \"path\"","webpack://nxls/external node-commonjs \"fs/promises\"","webpack://nxls/../../libs/shared/file-system/src/lib/file-exists.ts","webpack://nxls/external commonjs \"core-js/modules/es.string.starts-with.js\"","webpack://nxls/external commonjs \"@yarnpkg/fslib\"","webpack://nxls/external commonjs \"@yarnpkg/libzip\"","webpack://nxls/external commonjs \"jsonc-parser\"","webpack://nxls/../../libs/shared/file-system/src/lib/cache-json.ts","webpack://nxls/../../libs/shared/file-system/src/lib/directory-exists.ts","webpack://nxls/../../libs/shared/npm/src/lib/package-details.ts","webpack://nxls/external commonjs \"core-js/modules/es.array.includes.js\"","webpack://nxls/external commonjs \"core-js/modules/es.string.includes.js\"","webpack://nxls/../../libs/shared/npm/src/lib/pnp-dependencies.ts","webpack://nxls/../../libs/shared/npm/src/lib/workspace-dependencies.ts","webpack://nxls/../../libs/shared/npm/src/lib/npm-dependencies.ts","webpack://nxls/../../libs/shared/npm/src/lib/find-nx-package-path.ts","webpack://nxls/external commonjs \"semver\"","webpack://nxls/external commonjs \"nx/src/devkit-exports\"","webpack://nxls/external node-commonjs \"os\"","webpack://nxls/../../libs/shared/utils/src/lib/get-nx-execution-command.ts","webpack://nxls/external commonjs \"rxjs\"","webpack://nxls/external commonjs \"core-js/modules/es.object.assign.js\"","webpack://nxls/external commonjs \"core-js/modules/es.string.match.js\"","webpack://nxls/../../libs/language-server/workspace/src/lib/get-nx-workspace-package.ts","webpack://nxls/external node-commonjs \"perf_hooks\"","webpack://nxls/../../libs/language-server/workspace/src/lib/get-nx-workspace-config.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/get-nx-version.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/workspace.ts","webpack://nxls/external commonjs \"core-js/modules/es.symbol.description.js\"","webpack://nxls/external commonjs \"core-js/modules/es.array.flat.js\"","webpack://nxls/external commonjs \"core-js/modules/es.array.unscopables.flat.js\"","webpack://nxls/../../libs/shared/schema/src/schema.ts","webpack://nxls/../../libs/shared/schema/src/task-execution-messages.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/get-project-by-path.ts","webpack://nxls/../../libs/shared/schema/src/is-project-option.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/read-collections.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/get-executors.ts","webpack://nxls/external commonjs \"core-js/modules/es.array.reduce.js\"","webpack://nxls/../../libs/shared/json-schema/src/lib/create-builders-and-executors-schema.ts","webpack://nxls/../../libs/shared/json-schema/src/lib/completion-type.ts","webpack://nxls/../../libs/shared/json-schema/src/lib/common-json-schema.ts","webpack://nxls/../../libs/shared/json-schema/src/lib/project-json-schema.ts","webpack://nxls/../../libs/shared/json-schema/src/lib/package-json-schema.ts","webpack://nxls/../../libs/shared/json-schema/src/lib/nx-json-schema.ts","webpack://nxls/../../libs/language-server/capabilities/code-completion/src/lib/schema-completion.ts","webpack://nxls/../../libs/shared/json-schema/src/lib/workspace-json-schema.ts","webpack://nxls/../../libs/language-server/utils/src/lib/node-types.ts","webpack://nxls/../../libs/language-server/utils/src/lib/default-completion.ts","webpack://nxls/../../libs/language-server/capabilities/code-completion/src/lib/create-completion-path-item.ts","webpack://nxls/../../libs/language-server/capabilities/code-completion/src/lib/input-name-completion.ts","webpack://nxls/../../libs/language-server/utils/src/lib/find-project-root.ts","webpack://nxls/external commonjs \"fast-glob\"","webpack://nxls/../../libs/language-server/capabilities/code-completion/src/lib/path-completion.ts","webpack://nxls/../../libs/language-server/capabilities/code-completion/src/lib/tags-completion.ts","webpack://nxls/../../libs/language-server/capabilities/code-completion/src/lib/targets-completion.ts","webpack://nxls/../../libs/language-server/capabilities/code-completion/src/lib/get-completion-items.ts","webpack://nxls/../../libs/language-server/capabilities/code-completion/src/lib/project-target-completion.ts","webpack://nxls/../../libs/language-server/capabilities/code-completion/src/lib/project-completion.ts","webpack://nxls/../../libs/language-server/utils/src/lib/executor.ts","webpack://nxls/external commonjs \"nx/src/config/schema-utils\"","webpack://nxls/external commonjs \"vscode-languageserver\"","webpack://nxls/../../libs/language-server/capabilities/document-links/src/lib/create-range.ts","webpack://nxls/external commonjs \"@nx/devkit/src/executors/parse-target-string\"","webpack://nxls/external commonjs \"vscode-languageserver-textdocument\"","webpack://nxls/../../libs/language-server/utils/src/lib/language-model-cache.ts","webpack://nxls/../../libs/language-server/utils/src/lib/find-property.ts","webpack://nxls/../../libs/language-server/capabilities/document-links/src/lib/target-link.ts","webpack://nxls/../../libs/shared/file-system/src/lib/read-file.ts","webpack://nxls/../../libs/language-server/capabilities/hover/src/lib/get-hover.ts","webpack://nxls/external commonjs \"vscode-languageserver/node\"","webpack://nxls/../../libs/language-server/types/src/index.ts","webpack://nxls/external node-commonjs \"node:child_process\"","webpack://nxls/external commonjs \"nx/src/utils/package-manager\"","webpack://nxls/external commonjs \"@parcel/watcher\"","webpack://nxls/external commonjs \"nx/src/utils/ignore\"","webpack://nxls/external commonjs \"minimatch\"","webpack://nxls/../../libs/language-server/watcher/src/lib/watcher.ts","webpack://nxls/../../libs/shared/file-system/src/lib/list-files.ts","webpack://nxls/../../libs/shared/schema/src/normalize-schema.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/get-generators.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/get-generator-options.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/get-generator-context-v2.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/get-project-graph-output.ts","webpack://nxls/external node-commonjs \"child_process\"","webpack://nxls/external commonjs \"util\"","webpack://nxls/../../libs/shared/nx-console-plugins/src/lib/internal-plugins/name-and-directory.plugin.ts","webpack://nxls/../../libs/shared/nx-console-plugins/src/lib/internal-plugins/index.ts","webpack://nxls/../../libs/shared/nx-console-plugins/src/lib/internal-plugins/project-name-and-root-plugin.ts","webpack://nxls/../../libs/shared/nx-console-plugins/src/lib/internal-plugins/filter-internal-and-deprecated-processor.ts","webpack://nxls/../../libs/shared/nx-console-plugins/src/lib/internal-plugins/prefill-project-and-dir-processor.ts","webpack://nxls/../../libs/shared/nx-console-plugins/src/lib/internal-plugins/add-project-items-to-option-processor.ts","webpack://nxls/../../libs/shared/nx-console-plugins/src/lib/internal-plugins/git-clean-message-factory.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/nx-console-plugins.ts","webpack://nxls/external commonjs \"core-js/modules/es.string.trim.js\"","webpack://nxls/../../libs/language-server/workspace/src/lib/get-source-map.ts","webpack://nxls/external node-commonjs \"node:path\"","webpack://nxls/./src/main.ts","webpack://nxls/../../libs/language-server/utils/src/lib/merge-arrays.ts","webpack://nxls/../../libs/language-server/capabilities/definition/src/lib/get-definition.ts","webpack://nxls/../../libs/language-server/capabilities/document-links/src/lib/get-document-links.ts","webpack://nxls/../../libs/language-server/utils/src/lib/nx-reset.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/get-generator-context-from-path.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/create-project-graph.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/get-project-folder-tree.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/has-affected-projects.ts"],"sourcesContent":["var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 1;\nmodule.exports = webpackEmptyContext;","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 2;\nmodule.exports = webpackEmptyContext;","function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(() => {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = () => ([]);\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = 3;\nmodule.exports = webpackEmptyAsyncContext;","module.exports = require(\"nx/src/native\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.promise.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.regexp.to-string.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.string.ends-with.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.array.iterator.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/web.dom-collections.iterator.js\");","import { Logger } from '@nx-console/shared/schema';\nimport { Connection } from 'vscode-languageserver';\n\nlet log: Console['log'] | undefined;\n\nexport function setLspLogger(connection: Connection) {\n  if (!log) {\n    log = connection.console.log.bind(connection.console);\n  } else {\n    throw `Can't set logger twice`;\n  }\n}\n\nexport const lspLogger: Logger = {\n  log(message: string, ...args: any[]) {\n    log?.(\n      `[Nxls] - ${new Date(Date.now()).toISOString()} - ${message}\\n`,\n      ...args\n    );\n  },\n};\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"vscode-json-languageservice\");","import {\n  getLanguageService,\n  LanguageService,\n  LanguageServiceParams,\n  LanguageSettings,\n} from 'vscode-json-languageservice';\nimport { lspLogger } from './lsp-log';\n\nlet languageService: LanguageService | undefined;\n\nexport function configureJsonLanguageService(\n  params: LanguageServiceParams,\n  settings: LanguageSettings\n) {\n  languageService = getLanguageService(params);\n  languageService.configure(settings);\n\n  return languageService;\n}\n\nexport function getJsonLanguageService(): LanguageService | undefined {\n  if (!languageService) {\n    lspLogger.log('Language service not configured');\n  }\n\n  return languageService;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"request-light\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"vscode-uri\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fs\");","import {\n  xhr,\n  XHRResponse,\n  configure as configureHttpRequests,\n  getErrorStatusDescription,\n} from 'request-light';\nimport { URI } from 'vscode-uri';\nimport * as fs from 'fs';\nimport { Thenable } from 'vscode-json-languageservice';\n\nexport interface RequestService {\n  getContent(uri: string): Promise<string>;\n}\n\nfunction getHTTPRequestService(): RequestService {\n  return {\n    getContent(uri: string, _encoding?: string) {\n      const headers = { 'Accept-Encoding': 'gzip, deflate' };\n      return xhr({ url: uri, followRedirects: 5, headers }).then(\n        (response) => {\n          return response.responseText;\n        },\n        (error: XHRResponse) => {\n          return Promise.reject(\n            error.responseText ||\n              getErrorStatusDescription(error.status) ||\n              error.toString()\n          );\n        }\n      );\n    },\n  };\n}\n\nfunction getFileRequestService(): RequestService {\n  return {\n    getContent(location: string, encoding?: BufferEncoding) {\n      return new Promise((c, e) => {\n        const uri = URI.parse(location);\n        fs.readFile(uri.fsPath, encoding, (err, buf) => {\n          if (err) {\n            return e(err);\n          }\n          c(buf.toString());\n        });\n      });\n    },\n  };\n}\n\nexport function getSchemaRequestService(\n  handledSchemas: string[] = ['https', 'http', 'file']\n) {\n  const builtInHandlers: { [protocol: string]: RequestService | undefined } =\n    {};\n  for (const protocol of handledSchemas) {\n    if (protocol === 'file') {\n      builtInHandlers[protocol] = getFileRequestService();\n    } else if (protocol === 'http' || protocol === 'https') {\n      builtInHandlers[protocol] = getHTTPRequestService();\n    }\n  }\n  return (uri: string): Thenable<string> => {\n    const protocol = uri.substr(0, uri.indexOf(':'));\n\n    const builtInHandler = builtInHandlers[protocol];\n    if (builtInHandler) {\n      return builtInHandler.getContent(uri);\n    }\n    return Promise.reject('Unable to retrieve schema');\n  };\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.array.sort.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.object.from-entries.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.regexp.constructor.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.regexp.exec.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.string.replace.js\");","import { NxWorkspaceConfiguration } from '@nx-console/shared/types';\n\nexport function getPrimitiveValue(value: any): string | undefined {\n  if (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  ) {\n    return value.toString();\n  } else {\n    return undefined;\n  }\n}\n\nexport function sortWorkspaceProjects(\n  w: NxWorkspaceConfiguration\n): NxWorkspaceConfiguration {\n  const sortedProjects = Object.entries(w.projects || {}).sort(\n    (projectA, projectB) => projectA[0].localeCompare(projectB[0])\n  );\n  w.projects = Object.fromEntries(sortedProjects);\n  return w;\n}\n\nexport function hasKey<T extends object>(\n  obj: T,\n  key: PropertyKey\n): key is keyof T {\n  return key in obj;\n}\n\nexport function formatError(message: string, err: any): string {\n  if (err instanceof Error) {\n    const error = <Error>err;\n    return `${message}: ${error.message}\\n${error.stack}`;\n  } else if (typeof err === 'string') {\n    return `${message}: ${err}`;\n  } else if (err) {\n    return `${message}: ${err.toString()}`;\n  }\n  return message;\n}\n\nexport function matchWithWildcards(\n  text: string,\n  expression: string,\n  strict = true\n) {\n  const escapeRegex = (str: string) =>\n    str.replace(/([.*+?^=!:${}()|[\\]/\\\\])/g, '\\\\$1');\n  return new RegExp(\n    `${strict ? '^' : ''}${expression.split('*').map(escapeRegex).join('.*')}$`\n  ).test(text);\n}\n\nexport function debounce(callback: (...args: any[]) => any, wait: number) {\n  let timerId: NodeJS.Timeout;\n  return (...args: any[]) => {\n    clearTimeout(timerId);\n    timerId = setTimeout(() => {\n      return callback(...args);\n    }, wait);\n  };\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"path\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fs/promises\");","import { stat } from 'fs/promises';\n\nexport async function fileExists(filePath: string): Promise<boolean> {\n  try {\n    return (await stat(filePath)).isFile();\n  } catch {\n    return false;\n  }\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.string.starts-with.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@yarnpkg/fslib\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@yarnpkg/libzip\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"jsonc-parser\");","import * as path from 'path';\nimport { PosixFS } from '@yarnpkg/fslib';\nimport { ZipOpenFS, getLibzipSync as libzip } from '@yarnpkg/libzip';\n\nimport { parse as parseJson, ParseError } from 'jsonc-parser';\n\nconst zipOpenFs = new ZipOpenFS({ libzip });\nexport const crossFs = new PosixFS(zipOpenFs);\nexport const files: { [path: string]: string[] } = {};\nexport const fileContents: { [path: string]: any } = {};\n\nexport async function readAndParseJson(filePath: string) {\n  const content = await crossFs.readFilePromise(filePath, 'utf8');\n  try {\n    return JSON.parse(content);\n  } catch {\n    const errors: ParseError[] = [];\n    const result = parseJson(content, errors);\n\n    if (errors.length > 0) {\n      for (const { error, offset } of errors) {\n        // TODO(cammisuli): output this generically\n        // getOutputChannel().appendLine(\n        //   `${printParseErrorCode(\n        //     error\n        //   )} in JSON at position ${offset} in ${filePath}`\n        // );\n      }\n    }\n\n    return result;\n  }\n}\n\nexport function clearJsonCache(filePath: string, basedir = '') {\n  const fullFilePath = path.join(basedir, filePath);\n  return delete fileContents[fullFilePath];\n}\n\nexport async function readAndCacheJsonFile(\n  filePath: string | undefined,\n  basedir = ''\n): Promise<{ path: string; json: any }> {\n  if (!filePath) {\n    return {\n      path: '',\n      json: {},\n    };\n  }\n  let fullFilePath = path.join(basedir, filePath);\n  if (fullFilePath.startsWith('file:\\\\')) {\n    fullFilePath = fullFilePath.replace('file:\\\\', '');\n  }\n  try {\n    const stats = await crossFs.statPromise(fullFilePath);\n    if (fileContents[fullFilePath] || stats.isFile()) {\n      fileContents[fullFilePath] ||= await readAndParseJson(fullFilePath);\n      return {\n        path: fullFilePath,\n        json: fileContents[fullFilePath],\n      };\n    }\n  } catch (e) {\n    // TODO(cammisuli): output this generically\n    // getOutputChannel().appendLine(`${fullFilePath} does not exist`);\n  }\n\n  return {\n    path: fullFilePath,\n    json: {},\n  };\n}\n\n/**\n * Caches already created json contents to a file path\n */\nexport function cacheJson(filePath: string, basedir = '', content?: any) {\n  const fullFilePath = path.join(basedir, filePath);\n  if (fileContents[fullFilePath]) {\n    return {\n      json: fileContents[fullFilePath],\n      path: fullFilePath,\n    };\n  }\n\n  if (content) {\n    fileContents[fullFilePath] = content;\n  }\n  return {\n    json: content,\n    path: fullFilePath,\n  };\n}\n","import { stat } from 'fs/promises';\n\nexport async function directoryExists(filePath: string): Promise<boolean> {\n  try {\n    return (await stat(filePath)).isDirectory();\n  } catch {\n    return false;\n  }\n}\n","import { readAndCacheJsonFile } from '@nx-console/shared/file-system';\nimport { join } from 'path';\n\nexport async function packageDetails(packagePath: string) {\n  const { json } = await readAndCacheJsonFile(\n    join(packagePath, 'package.json')\n  );\n  return {\n    packagePath,\n    packageName: json.name,\n    packageJson: json,\n  };\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.array.includes.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.string.includes.js\");","import type { PnpApi } from '@yarnpkg/pnp';\nimport { join } from 'path';\nimport { fileExists } from '@nx-console/shared/file-system';\n\nlet PNP_API: PnpApi;\n\nasync function getPnpFile(workspacePath: string) {\n  const extensions = ['.cjs', '.js'];\n  for (const ext of extensions) {\n    try {\n      const fileName = `.pnp${ext}`;\n      const pnpFile = join(workspacePath, fileName);\n      if (await fileExists(pnpFile)) {\n        return pnpFile;\n      }\n    } catch {\n      return;\n    }\n  }\n}\n\nasync function pnpApi(workspacePath: string) {\n  const pnpFile = await getPnpFile(workspacePath);\n  if (!pnpFile) {\n    return;\n  }\n\n  if (!PNP_API) {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const pnp = require(pnpFile);\n    pnp.setup();\n    PNP_API = pnp;\n  }\n\n  return PNP_API;\n}\n\nexport async function isWorkspaceInPnp(workspacePath: string) {\n  try {\n    const file = await getPnpFile(workspacePath);\n    return !!file;\n  } catch {\n    return false;\n  }\n}\n\nexport async function pnpDependencies(workspacePath: string) {\n  const pnp = await pnpApi(workspacePath);\n\n  if (!pnp) {\n    return [];\n  }\n\n  pnp.resolveRequest;\n\n  const dependencies = [];\n  for (const locator of pnp.getDependencyTreeRoots()) {\n    const pkg = pnp.getPackageInformation(locator);\n    if (!pkg?.packageDependencies) {\n      continue;\n    }\n    for (const [name, reference] of pkg?.packageDependencies ?? {}) {\n      // Unmet peer dependencies\n      if (reference === null) continue;\n      if (!Array.isArray(reference) && reference.startsWith('workspace:'))\n        continue;\n\n      const path = await pnpDependencyPath(workspacePath, name);\n      if (path) {\n        dependencies.push(path);\n      }\n    }\n  }\n  return dependencies;\n}\n\nexport async function pnpDependencyPath(\n  workspacePath: string,\n  dependencyName: string\n) {\n  try {\n    const pnp = await pnpApi(workspacePath);\n\n    if (!pnp) {\n      return;\n    }\n\n    let path: string =\n      pnp.resolveToUnqualified(dependencyName, workspacePath + '/') ?? '';\n    if (path.includes('__virtual__')) {\n      path = pnp.resolveVirtual?.(path) ?? '';\n    }\n\n    return path;\n  } catch {\n    return;\n  }\n}\n","import { directoryExists } from '@nx-console/shared/file-system';\nimport { WorkspaceProjects } from '@nx-console/shared/schema';\nimport { NxVersion } from '@nx-console/shared/types';\nimport { stat } from 'fs/promises';\nimport { join } from 'path';\nimport { npmDependencies } from './npm-dependencies';\nimport { packageDetails } from './package-details';\nimport {\n  isWorkspaceInPnp,\n  pnpDependencies,\n  pnpDependencyPath,\n} from './pnp-dependencies';\n\n/**\n * Get dependencies for the current workspace.\n * This is needed to continue to support Angular CLI projects.\n *\n */\n\nexport async function workspaceDependencies(\n  workspacePath: string,\n  nxVersion: NxVersion,\n  projects?: WorkspaceProjects\n): Promise<string[]> {\n  const dependencies: string[] = [];\n\n  dependencies.push(\n    ...(await localDependencies(workspacePath, nxVersion, projects))\n  );\n\n  if (await isWorkspaceInPnp(workspacePath)) {\n    dependencies.push(...(await pnpDependencies(workspacePath)));\n  }\n\n  dependencies.push(...(await npmDependencies(workspacePath)));\n\n  return dependencies;\n}\n\nexport async function workspaceDependencyPath(\n  workspacePath: string,\n  workspaceDependencyName: string\n) {\n  if (workspaceDependencyName.startsWith('.')) {\n    return join(workspacePath, workspaceDependencyName);\n  }\n\n  if (await isWorkspaceInPnp(workspacePath)) {\n    return pnpDependencyPath(workspacePath, workspaceDependencyName);\n  }\n\n  const nodeModulesPath = join(\n    workspacePath,\n    'node_modules',\n    workspaceDependencyName\n  );\n  const encapsulatedPath = join(\n    workspacePath,\n    '.nx',\n    'installation',\n    'node_modules',\n    workspaceDependencyName\n  );\n\n  try {\n    if (await directoryExists(nodeModulesPath)) {\n      return nodeModulesPath;\n    } else if (await directoryExists(encapsulatedPath)) {\n      return encapsulatedPath;\n    } else {\n      return undefined;\n    }\n  } catch {\n    return;\n  }\n}\n\nexport async function localDependencyPath(\n  workspacePath: string,\n  workspaceDependencyName: string,\n  projects: WorkspaceProjects\n): Promise<string | undefined> {\n  for (const project of Object.values(projects)) {\n    const projectPath = join(workspacePath, project.root);\n    const pkgDetails = await packageDetails(projectPath);\n    if (pkgDetails.packageName === workspaceDependencyName) {\n      return pkgDetails.packagePath;\n    }\n  }\n}\n\nasync function localDependencies(\n  workspacePath: string,\n  version: NxVersion,\n  projects?: WorkspaceProjects\n): Promise<string[]> {\n  if (!projects) {\n    return [];\n  }\n\n  // Local plugins do not work with nxVersion less than 13\n  if (version.major < 13) {\n    return [];\n  }\n\n  const packages = Object.values(projects).map(\n    (project) => `${workspacePath}/${project.root}/package.json`\n  );\n\n  const existingPackages: string[] = [];\n\n  for (const pkg of packages) {\n    try {\n      const fileStat = await stat(pkg);\n      if (fileStat.isFile()) {\n        existingPackages.push(pkg.replace('/package.json', ''));\n      }\n    } catch {\n      // noop\n    }\n  }\n\n  return existingPackages;\n}\n","import { stat, readdir } from 'fs/promises';\nimport { join } from 'path';\n\n/**\n * Get a flat list of all node_modules folders in the workspace.\n * This is needed to continue to support Angular CLI projects.\n *\n * @param workspacePath\n * @returns\n */\nexport async function npmDependencies(workspacePath: string) {\n  const nodeModules = join(workspacePath, 'node_modules');\n  const nodeModulesEncapsulated = join(\n    workspacePath,\n    '.nx',\n    'installation',\n    'node_modules'\n  );\n\n  let nodeModulesDir = nodeModules;\n\n  const res: string[] = [];\n  try {\n    if (!(await stat(nodeModules)).isDirectory()) {\n      return res;\n    }\n  } catch {\n    try {\n      if (!(await stat(nodeModulesEncapsulated)).isDirectory()) {\n        return res;\n      } else {\n        nodeModulesDir = nodeModulesEncapsulated;\n      }\n    } catch {\n      return res;\n    }\n  }\n\n  const dirContents = await readdir(nodeModulesDir);\n\n  for (const npmPackageOrScope of dirContents) {\n    try {\n      if (npmPackageOrScope.startsWith('.')) {\n        continue;\n      }\n\n      const packageStats = await stat(join(nodeModulesDir, npmPackageOrScope));\n      if (!packageStats.isDirectory()) {\n        continue;\n      }\n\n      if (npmPackageOrScope.startsWith('@')) {\n        (await readdir(join(nodeModulesDir, npmPackageOrScope))).forEach(\n          (p) => {\n            res.push(`${nodeModulesDir}/${npmPackageOrScope}/${p}`);\n          }\n        );\n      } else {\n        res.push(`${nodeModulesDir}/${npmPackageOrScope}`);\n      }\n    } catch (e) {\n      // ignore packages where reading them causes an error\n      continue;\n    }\n  }\n\n  return res;\n}\n","import { join } from 'path';\nimport { fileExists } from '@nx-console/shared/file-system';\nimport { workspaceDependencyPath } from './workspace-dependencies';\n\n/**\n * Finds the local Nx package in the workspace.\n *\n * It will try to look for the `nx` package, with the specific file. If it does not exist, it will try to look for the `@nrwl/workspace` package, with the specific file\n * @param workspacePath\n * @returns\n */\nexport async function findNxPackagePath(\n  workspacePath: string,\n  filePath: string\n): Promise<string | undefined> {\n  const buildPath = (base: string) => join(base, filePath);\n\n  const nxWorkspaceDepPath = await workspaceDependencyPath(workspacePath, 'nx');\n  if (nxWorkspaceDepPath) {\n    const path = buildPath(nxWorkspaceDepPath);\n    if (await fileExists(path)) {\n      return path;\n    }\n  }\n\n  const nrwlWorkspaceDepPath = await workspaceDependencyPath(\n    workspacePath,\n    '@nrwl/workspace'\n  );\n  if (nrwlWorkspaceDepPath) {\n    const path = buildPath(nrwlWorkspaceDepPath);\n    if (await fileExists(path)) {\n      return path;\n    }\n  }\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"semver\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"nx/src/devkit-exports\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"os\");","import {\n  detectPackageManager,\n  getPackageManagerCommand,\n} from 'nx/src/devkit-exports';\nimport { platform } from 'os';\n\n/**\n * see `getShellExecutionForConfig` for a vscode-specific implementation of this\n */\nexport function getNxExecutionCommand(config: {\n  cwd: string;\n  displayCommand: string;\n  encapsulatedNx: boolean;\n}): string {\n  let command = config.displayCommand;\n  if (config.encapsulatedNx) {\n    if (platform() == 'win32') {\n      command = command.replace(/^nx/, './nx.bat');\n    } else {\n      command = command.replace(/^nx/, './nx');\n    }\n  } else {\n    const packageManager = detectPackageManager(config.cwd);\n    const packageManagerCommand = getPackageManagerCommand(packageManager);\n    if (packageManager === 'yarn') {\n      command = `${packageManagerCommand.exec} --silent ${command}`;\n    } else {\n      command = `${packageManagerCommand.exec} ${command}`;\n    }\n  }\n\n  return command;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"rxjs\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.object.assign.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.string.match.js\");","// import { getOutputChannel } from '@nx-console/utils';\nimport type * as NxFileUtils from 'nx/src/project-graph/file-utils';\nimport type * as NxProjectGraph from 'nx/src/project-graph/project-graph';\nimport type * as NxProjectGraphFileUtils from 'nx/src/project-graph/file-map-utils';\nimport type * as NxDaemonClient from 'nx/src/daemon/client/client';\nimport type * as NxOutput from 'nx/src/utils/output';\nimport { platform } from 'os';\nimport { join } from 'path';\nimport { findNxPackagePath } from '@nx-console/shared/npm';\nimport { Logger } from '@nx-console/shared/schema';\n\nexport async function getNxDaemonClient(\n  workspacePath: string,\n  logger: Logger\n): Promise<typeof NxDaemonClient> {\n  const importPath = await findNxPackagePath(\n    workspacePath,\n    join('src', 'daemon', 'client', 'client.js')\n  );\n  return getNxPackage(importPath, logger);\n}\n\nexport async function getNxOutput(\n  workspacePath: string,\n  logger: Logger\n): Promise<typeof NxOutput | undefined> {\n  const importPath = await findNxPackagePath(\n    workspacePath,\n    join('src', 'utils', 'output.js')\n  );\n\n  if (!importPath) {\n    return;\n  }\n\n  return getNxPackage(importPath, logger);\n}\n\nexport async function getNxProjectGraphUtils(\n  workspacePath: string,\n  logger: Logger\n): Promise<typeof NxProjectGraphFileUtils | undefined> {\n  const importPath = await findNxPackagePath(\n    workspacePath,\n    join('src', 'project-graph', 'file-map-utils.js')\n  );\n\n  if (!importPath) {\n    return;\n  }\n\n  return getNxPackage(importPath, logger);\n}\n\nexport async function getNxProjectGraph(\n  workspacePath: string,\n  logger: Logger\n): Promise<typeof NxProjectGraph> {\n  let importPath = await findNxPackagePath(\n    workspacePath,\n    join('src', 'project-graph', 'project-graph.js')\n  );\n\n  if (!importPath) {\n    importPath = await findNxPackagePath(\n      workspacePath,\n      join('src', 'core', 'project-graph', 'project-graph.js')\n    );\n  }\n\n  return getNxPackage(importPath, logger);\n}\n\n/**\n * Get the local installed version of @nx/workspace\n */\nexport async function getNxWorkspacePackageFileUtils(\n  workspacePath: string,\n  logger: Logger\n): Promise<typeof NxFileUtils> {\n  let importPath = await findNxPackagePath(\n    workspacePath,\n    join('src', 'project-graph', 'file-utils.js')\n  );\n\n  if (!importPath) {\n    importPath = await findNxPackagePath(\n      workspacePath,\n      join('src', 'core', 'file-utils.js')\n    );\n  }\n\n  return getNxPackage(importPath, logger);\n}\n\nexport async function getNxPackage<T>(\n  importPath: string | undefined,\n  logger: Logger\n): Promise<T> {\n  if (!importPath) {\n    logger?.log(\n      `Unable to load the ${importPath} dependency from the workspace. Please ensure that the proper dependencies are installed locally.`\n    );\n    throw 'local Nx dependency not found';\n  }\n\n  if (platform() === 'win32') {\n    importPath = importPath.replace(/\\\\/g, '/');\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const imported = require(importPath);\n\n  logger?.log(`Using local Nx package at ${importPath}`);\n\n  return imported;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"perf_hooks\");","import type {\n  NxJsonConfiguration,\n  ProjectFileMap,\n  ProjectGraph,\n  ProjectsConfigurations,\n} from 'nx/src/devkit-exports';\nimport { lspLogger } from '@nx-console/language-server/utils';\nimport { readAndCacheJsonFile } from '@nx-console/shared/file-system';\nimport { Logger } from '@nx-console/shared/schema';\nimport { NxVersion, NxWorkspaceConfiguration } from '@nx-console/shared/types';\nimport { join } from 'path';\nimport { SemVer, coerce, gte } from 'semver';\nimport {\n  getNxDaemonClient,\n  getNxOutput,\n  getNxProjectGraph,\n  getNxProjectGraphUtils,\n  getNxWorkspacePackageFileUtils,\n} from './get-nx-workspace-package';\nimport { performance } from 'perf_hooks';\n\nexport async function getNxWorkspaceConfig(\n  workspacePath: string,\n  nxVersion: NxVersion,\n  logger: Logger\n): Promise<{\n  workspaceConfiguration: NxWorkspaceConfiguration;\n  daemonEnabled?: boolean;\n  error?: string;\n}> {\n  let projectGraph: ProjectGraph | null = null;\n  let sourceMaps: Record<string, Record<string, string[]>> | undefined =\n    undefined;\n\n  let error: string | undefined;\n\n  const start = performance.now();\n  logger.log('Retrieving workspace configuration');\n\n  if (nxVersion.major < 12) {\n    lspLogger.log('Major version is less than 12');\n    return readWorkspaceConfigs(workspacePath);\n  }\n\n  try {\n    // Always set the CI env variable to false\n    (process.env as any).CI = false;\n    (process.env as any).NX_PROJECT_GLOB_CACHE = false;\n    (process.env as any).NX_WORKSPACE_ROOT_PATH = workspacePath;\n    const [\n      nxWorkspacePackage,\n      nxProjectGraph,\n      nxOutput,\n      nxProjectGraphUtils,\n      nxDaemonClientModule,\n    ] = await Promise.all([\n      getNxWorkspacePackageFileUtils(workspacePath, logger),\n      getNxProjectGraph(workspacePath, logger),\n      getNxOutput(workspacePath, logger),\n      getNxProjectGraphUtils(workspacePath, logger),\n      getNxDaemonClient(workspacePath, logger),\n    ]);\n\n    let workspaceConfiguration: NxWorkspaceConfiguration | undefined =\n      undefined;\n    if (!gte(nxVersion.full, '17.3.0')) {\n      try {\n        workspaceConfiguration = nxWorkspacePackage.readWorkspaceConfig({\n          format: 'nx',\n          path: workspacePath,\n        });\n      } catch (e) {\n        logger.log('Unable to read workspace config from nx workspace package');\n        workspaceConfiguration = (await readWorkspaceConfigs(workspacePath))\n          .workspaceConfiguration;\n        error = `${e.stack}`;\n      }\n    }\n    try {\n      process.exit = function (code?: number) {\n        console.warn('process.exit called with code', code);\n      } as (code?: number) => never;\n\n      if (nxOutput !== undefined) {\n        nxOutput.output.error = (output) => {\n          // do nothing\n        };\n      }\n\n      if (nxVersion.major < 13) {\n        projectGraph = (nxProjectGraph as any).createProjectGraph();\n      } else if (gte(nxVersion.full, '17.2.0')) {\n        lspLogger.log('createProjectGraphAndSourceMapsAsync');\n        const projectGraphAndSourceMaps = await (\n          nxProjectGraph as any\n        ).createProjectGraphAndSourceMapsAsync({\n          exitOnError: false,\n        });\n        projectGraph = projectGraphAndSourceMaps.projectGraph;\n        sourceMaps = projectGraphAndSourceMaps.sourceMaps;\n        lspLogger.log('createProjectGraphAndSourceMapsAsync successful');\n      } else {\n        lspLogger.log('createProjectGraphAsync');\n        projectGraph = await nxProjectGraph.createProjectGraphAsync({\n          exitOnError: false,\n        });\n        lspLogger.log('createProjectGraphAsync successful');\n      }\n    } catch (e) {\n      lspLogger.log('Unable to get project graph');\n      lspLogger.log(e.stack);\n      error = `${e.stack}`;\n    }\n\n    let projectFileMap: ProjectFileMap = {};\n    if (gte(nxVersion.full, '16.3.1') && projectGraph) {\n      projectFileMap =\n        (await nxProjectGraphUtils?.createProjectFileMapUsingProjectGraph(\n          projectGraph\n        )) ?? {};\n    } else {\n      Object.keys(projectGraph?.nodes ?? {}).forEach((projectName) => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        projectFileMap[projectName] =\n          (projectGraph?.nodes[projectName].data as any).files ?? [];\n      });\n    }\n\n    if (!workspaceConfiguration) {\n      workspaceConfiguration = {\n        version: 1,\n        projects: {},\n      };\n    }\n\n    workspaceConfiguration = createNxWorkspaceConfiguration(\n      workspaceConfiguration,\n      projectGraph,\n      projectFileMap,\n      sourceMaps\n    );\n\n    // reset the daemon client after getting all required information from the daemon\n    if (nxDaemonClientModule) {\n      lspLogger.log('Resetting daemon client');\n      nxDaemonClientModule.daemonClient?.reset();\n    }\n\n    const end = performance.now();\n    logger.log(`Retrieved workspace configuration in: ${end - start} ms`);\n\n    return {\n      workspaceConfiguration,\n      error,\n    };\n  } catch (e) {\n    lspLogger.log(`Unable to get nx workspace configuration: ${e}`);\n    const config = await readWorkspaceConfigs(workspacePath);\n    return { ...config, error: `${e}` };\n  }\n}\n\nasync function readWorkspaceConfigs(basedir: string): Promise<{\n  workspaceConfiguration: NxWorkspaceConfiguration;\n  configPath: string;\n}> {\n  const workspaceJson: ProjectsConfigurations = (\n    await readAndCacheJsonFile('workspace.json', basedir)\n  ).json;\n\n  const nxJson: NxJsonConfiguration = (\n    await readAndCacheJsonFile('nx.json', basedir)\n  ).json;\n  return {\n    workspaceConfiguration: {\n      ...workspaceJson,\n      ...nxJson,\n      projects: {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ...((nxJson as any).projects ?? {}),\n        ...workspaceJson.projects,\n      },\n    },\n    configPath: join(basedir, 'workspace.json'),\n  };\n}\n\nfunction createNxWorkspaceConfiguration(\n  workspaceConfiguration: NxWorkspaceConfiguration,\n  projectGraph: ProjectGraph | null,\n  projectFileMap: ProjectFileMap,\n  sourceMaps: Record<string, Record<string, string[]>> | undefined\n) {\n  if (!projectGraph) {\n    return workspaceConfiguration;\n  }\n\n  // We always want to get the latest projects from the graph, rather than the ones in the workspace configuration\n  const modifiedWorkspaceConfiguration: NxWorkspaceConfiguration = {\n    ...workspaceConfiguration,\n    projects: {},\n  };\n\n  for (const [projectName, node] of Object.entries(projectGraph.nodes)) {\n    const workspaceProject = workspaceConfiguration?.projects[projectName];\n\n    if (!workspaceProject) {\n      // Certain versions of Nx will include npm, (or other third party dependencies) in the project graph nodes.\n      // These usually start with `npm:depname`\n      // We dont want to include them.\n      if (projectName.match(/:/)) {\n        continue;\n      }\n\n      modifiedWorkspaceConfiguration.projects[projectName] = {\n        root: node.data.root,\n        targets: node.data.targets ?? {},\n        name: projectName,\n        tags: node.data.tags ?? [],\n        files: projectFileMap[projectName],\n      };\n    } else {\n      modifiedWorkspaceConfiguration.projects[projectName] = {\n        ...workspaceProject,\n        targets: node.data.targets ?? {},\n        files: projectFileMap[projectName],\n        name: projectName,\n      };\n    }\n  }\n\n  return { ...modifiedWorkspaceConfiguration, sourceMaps };\n}\n","import { findNxPackagePath } from '@nx-console/shared/npm';\nimport { NxVersion } from '@nx-console/shared/types';\nimport { coerce, SemVer } from 'semver';\n\nlet nxWorkspacePackageJson: { version: string } | undefined;\nlet loadedNxPackage = false;\n\nconst defaultSemver = new SemVer('0.0.0');\n\nexport async function getNxVersion(workspacePath: string): Promise<NxVersion> {\n  if (!loadedNxPackage) {\n    const packagePath = await findNxPackagePath(workspacePath, 'package.json');\n\n    if (!packagePath) {\n      return {\n        major: defaultSemver.major,\n        minor: defaultSemver.minor,\n        full: defaultSemver.version,\n      };\n    }\n\n    nxWorkspacePackageJson = require(packagePath);\n    loadedNxPackage = true;\n  }\n\n  if (!nxWorkspacePackageJson) {\n    return {\n      major: defaultSemver.major,\n      minor: defaultSemver.minor,\n      full: defaultSemver.version,\n    };\n  }\n  const nxVersion = coerce(nxWorkspacePackageJson.version);\n  if (!nxVersion) {\n    return {\n      major: defaultSemver.major,\n      minor: defaultSemver.minor,\n      full: defaultSemver.version,\n    };\n  }\n\n  return {\n    major: nxVersion.major,\n    minor: nxVersion.minor,\n    full: nxVersion.version,\n  };\n}\n\nexport async function resetNxVersionCache() {\n  loadedNxPackage = false;\n  nxWorkspacePackageJson = undefined;\n}\n","import { formatError, sortWorkspaceProjects } from '@nx-console/shared/utils';\n\nimport { clearJsonCache, fileExists } from '@nx-console/shared/file-system';\nimport { Logger } from '@nx-console/shared/schema';\nimport { join } from 'path';\nimport {\n  firstValueFrom,\n  from,\n  iif,\n  of,\n  ReplaySubject,\n  switchMap,\n  tap,\n} from 'rxjs';\nimport { getNxWorkspaceConfig } from './get-nx-workspace-config';\nimport { NxWorkspace } from '@nx-console/shared/types';\nimport { getNxVersion } from './get-nx-version';\nimport { lspLogger } from '@nx-console/language-server/utils';\n\nconst enum Status {\n  not_started,\n  in_progress,\n  cached,\n}\n\nlet cachedReplay = new ReplaySubject<NxWorkspace>();\nlet status: Status = Status.not_started;\n\nfunction resetStatus(workspacePath: string) {\n  status = Status.not_started;\n  cachedReplay = new ReplaySubject<NxWorkspace>();\n  // Clear out the workspace config path, needed for older nx workspaces\n  clearJsonCache('workspace.json', workspacePath);\n  clearJsonCache('nx.json', workspacePath);\n}\n\nexport async function nxWorkspace(\n  workspacePath: string,\n  logger: Logger = {\n    log(message) {\n      console.log(message);\n    },\n  },\n  reset?: boolean\n): Promise<NxWorkspace> {\n  if (reset) {\n    resetStatus(workspacePath);\n  }\n\n  return firstValueFrom(\n    iif(\n      () => status === Status.not_started,\n      of({}).pipe(\n        tap(() => {\n          status = Status.in_progress;\n        }),\n        switchMap(() => from(_workspace(workspacePath, logger))),\n        tap((workspace) => {\n          cachedReplay.next(workspace);\n          status = Status.cached;\n        })\n      ),\n      cachedReplay\n    )\n  );\n}\n\nasync function _workspace(\n  workspacePath: string,\n  logger: Logger\n): Promise<NxWorkspace> {\n  try {\n    const nxVersion = await getNxVersion(workspacePath);\n    const config = await getNxWorkspaceConfig(workspacePath, nxVersion, logger);\n\n    const isLerna = await fileExists(join(workspacePath, 'lerna.json'));\n    return {\n      validWorkspaceJson: true,\n      workspace: sortWorkspaceProjects(config.workspaceConfiguration),\n      daemonEnabled: config.daemonEnabled,\n      isLerna,\n      isEncapsulatedNx: !!config.workspaceConfiguration.installation,\n      workspaceLayout: {\n        appsDir: config.workspaceConfiguration.workspaceLayout?.appsDir,\n        libsDir: config.workspaceConfiguration.workspaceLayout?.libsDir,\n      },\n      error: config.error,\n      nxVersion,\n      workspacePath,\n    };\n  } catch (e) {\n    logger.log(formatError('Invalid workspace', e));\n\n    // Default to nx workspace\n    return {\n      validWorkspaceJson: false,\n      workspace: {\n        projects: {},\n        version: 2,\n      },\n      workspacePath,\n      isEncapsulatedNx: false,\n      nxVersion: {\n        major: 0,\n        minor: 0,\n        full: '0.0.0',\n      },\n      isLerna: false,\n      workspaceLayout: {\n        appsDir: 'apps',\n        libsDir: 'libs',\n      },\n    };\n  }\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.symbol.description.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.array.flat.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.array.unscopables.flat.js\");","import type { ProjectsConfigurations } from 'nx/src/devkit-exports';\nimport type { Schema } from 'nx/src/utils/params';\n\nexport enum OptionType {\n  Any = 'any',\n  Array = 'array',\n  Boolean = 'boolean',\n  Number = 'number',\n  String = 'string',\n}\n\nexport type OptionPropertyDescription = Schema['properties'][number];\n\nexport type CliOption = {\n  name: string;\n  originalName?: string;\n  positional?: number;\n  alias?: string;\n  hidden?: boolean;\n  deprecated?: boolean | string;\n} & OptionPropertyDescription;\n\nexport interface Option extends CliOption {\n  tooltip?: string;\n  itemTooltips?: ItemTooltips;\n  items?: string[] | ItemsWithEnum;\n  aliases: string[];\n  isRequired: boolean;\n  'x-dropdown'?: 'projects';\n  'x-priority'?: 'important' | 'internal';\n  'x-hint'?: string;\n}\n\nexport interface ItemTooltips {\n  [itemValue: string]: string;\n}\n\nexport interface ItemsWithEnum {\n  enum: string[];\n  type: OptionType;\n}\n\nexport type XPrompt = string | LongFormXPrompt;\nexport interface LongFormXPrompt {\n  message: string;\n  type: 'confirmation' | 'input' | 'list' | string;\n  multiselect?: boolean;\n  items?: (string | OptionItemLabelValue)[];\n}\n\nexport interface OptionItemLabelValue {\n  label: string;\n  value: string;\n}\n\nexport interface TaskExecutionMessage {\n  command: string;\n  positional: string;\n  flags: string[];\n}\n\nexport interface TaskExecutionSchema {\n  name: string;\n  command: string;\n  collection?: string;\n  positional: string;\n  builder?: string;\n  description: string;\n  configurations?: TargetConfiguration[];\n  options: Option[];\n  contextValues?: {\n    path?: string;\n    directory?: string;\n    project?: string;\n    projectName?: string;\n  };\n}\n\nexport type CollectionInfo = GeneratorCollectionInfo | ExecutorCollectionInfo;\n\nexport interface GeneratorCollectionInfo {\n  type: 'generator';\n  name: string;\n  /**\n   * The path to the file that lists all generators in the collection.\n   */\n  configPath: string;\n  schemaPath: string;\n  data?: Generator;\n}\n\nexport interface ExecutorCollectionInfo {\n  type: 'executor';\n  name: string;\n  /**\n   * The path to the file that lists all executors in the collection.\n   */\n  configPath: string;\n  schemaPath: string;\n  implementationPath: string;\n}\n\nexport enum GeneratorType {\n  Application = 'application',\n  Library = 'library',\n  Other = 'other',\n}\n\nexport interface Generator {\n  collection: string;\n  name: string;\n  description: string;\n  options?: Option[];\n  type: GeneratorType;\n  aliases: string[];\n}\n\nexport interface DefaultValue {\n  name: string;\n  defaultValue: string | undefined;\n}\n\nexport interface TargetConfiguration {\n  name: string;\n  defaultValues: DefaultValue[];\n}\n\nexport interface Targets {\n  name: string;\n  project: string;\n  builder: string | undefined;\n  description: string;\n  configurations: TargetConfiguration[];\n  options: CliOption[];\n}\n\nexport const WORKSPACE_GENERATOR_NAME_REGEX =\n  /^workspace-(schematic|generator):(.+)/;\n\nexport type WorkspaceProjects = ProjectsConfigurations['projects'];\n\nexport interface Logger {\n  log(message: string): void;\n}\n","import { TaskExecutionMessage, TaskExecutionSchema } from './schema';\n\nexport interface GlobalConfigurationData {\n  enableTaskExecutionDryRunOnChange: boolean;\n}\n\n// Task execution output messages\nexport type TaskExecutionOutputMessage =\n  | TaskExecutionFormInitOutputMessage\n  | TaskExecutionRunCommandOutputMessage;\n\nexport enum TaskExecutionOutputMessageType {\n  TaskExecutionFormInit = 'output-init',\n  RunCommand = 'run-command',\n}\n\nexport class TaskExecutionRunCommandOutputMessage {\n  readonly payloadType = TaskExecutionOutputMessageType.RunCommand;\n\n  constructor(public readonly payload: TaskExecutionMessage) {}\n}\n\nexport class TaskExecutionFormInitOutputMessage {\n  readonly payloadType = TaskExecutionOutputMessageType.TaskExecutionFormInit;\n}\n\n// Task execution input messages\nexport type TaskExecutionInputMessage =\n  | TaskExecutionSchemaInputMessage\n  | TaskExecutionGlobalConfigurationInputMessage\n  | TaskExecutionSetStylesMessage;\n\nexport enum TaskExecutionInputMessageType {\n  SetTaskExecutionSchema = 'generator',\n  SetGlobalConfiguration = 'config',\n  SetStyles = 'style',\n}\n\nexport class TaskExecutionSchemaInputMessage {\n  readonly payloadType = TaskExecutionInputMessageType.SetTaskExecutionSchema;\n\n  constructor(public readonly payload: TaskExecutionSchema) {}\n}\n\nexport class TaskExecutionGlobalConfigurationInputMessage {\n  readonly payloadType = TaskExecutionInputMessageType.SetGlobalConfiguration;\n\n  constructor(public readonly payload: GlobalConfigurationData) {}\n}\n\nexport class TaskExecutionSetStylesMessage {\n  readonly payloadType = TaskExecutionInputMessageType.SetStyles;\n\n  constructor(\n    public readonly payload: {\n      backgroundColor: string;\n      highlightTextColor: string;\n      secondaryTextColor: string;\n      fieldBackground: string;\n      fontFamily: string;\n      fontSize: string;\n    }\n  ) {}\n}\n","import { directoryExists } from '@nx-console/shared/file-system';\nimport type { ProjectConfiguration } from 'nx/src/devkit-exports';\nimport { isAbsolute, join, normalize, relative, sep } from 'path';\nimport { nxWorkspace } from './workspace';\nimport { lspLogger } from '@nx-console/language-server/utils';\n\nlet _rootProjectMap: Record<string, ProjectConfiguration> | undefined;\n\nexport function resetProjectPathCache() {\n  _rootProjectMap = undefined;\n}\n\nexport async function getProjectByPath(\n  path: string,\n  workspacePath: string\n): Promise<ProjectConfiguration | undefined> {\n  path = normalize(path);\n  // windows paths like /c:/Users/... aren't correctly picked up by normalize() so we need to handle them ourselves\n  path = path.startsWith(sep) ? path.substring(1) : path;\n  const projectsMap = await getProjectsByPaths([path], workspacePath);\n  return projectsMap?.[path] || undefined;\n}\n\nexport async function getProjectByRoot(\n  rootPath: string,\n  workspacePath: string\n): Promise<ProjectConfiguration | undefined> {\n  if (_rootProjectMap && _rootProjectMap[rootPath]) {\n    return _rootProjectMap[rootPath];\n  }\n\n  const { workspace } = await nxWorkspace(workspacePath);\n  const rootProjectMap: Record<string, ProjectConfiguration> = {};\n  const projectEntries = Object.entries(workspace.projects);\n  for (const [, projectConfig] of projectEntries) {\n    rootProjectMap[projectConfig.root] = projectConfig;\n  }\n  _rootProjectMap = rootProjectMap;\n\n  return _rootProjectMap?.[rootPath];\n}\n\nexport async function getProjectsByPaths(\n  paths: string[] | undefined,\n  workspacePath: string\n): Promise<Record<string, ProjectConfiguration> | undefined> {\n  if (!paths) {\n    return undefined;\n  }\n  // windows paths like /c:/Users/... aren't correctly picked up by normalize() so we need to handle them ourselves\n  const pathsNormalized = paths\n    .map((p) => normalize(p))\n    .map((p) => (p.startsWith(sep) ? p.substring(1) : p));\n  workspacePath = normalize(workspacePath);\n  workspacePath = workspacePath.startsWith(sep)\n    ? workspacePath.substring(1)\n    : workspacePath;\n\n  const { workspace } = await nxWorkspace(workspacePath);\n  const pathsMap = new Map<\n    string,\n    { relativePath: string; isDirectory: boolean }\n  >();\n  for (const path of pathsNormalized) {\n    lspLogger.log(\n      `workspacePath: ${workspacePath}, path ${path}, relative: ${relative(\n        workspacePath,\n        path\n      )}`\n    );\n    pathsMap.set(path, {\n      relativePath: relative(workspacePath, path),\n      isDirectory: await directoryExists(path),\n    });\n  }\n\n  const projectEntries = Object.entries(workspace.projects);\n\n  const foundProjects: Map<string, ProjectConfiguration> = new Map();\n\n  for (const [projectName, projectConfig] of projectEntries) {\n    // If there is no files array, it's an old version of Nx and we need backwards compatibility\n    if (!projectConfig.files) {\n      new Map(pathsMap).forEach((_, path) => {\n        const foundProject = findByFilePath(\n          [projectName, projectConfig],\n          workspacePath,\n          path\n        );\n        if (foundProject) {\n          foundProjects.set(path, foundProject);\n          pathsMap.delete(path);\n        }\n      });\n      continue;\n    }\n\n    // project check for directories\n    new Map(pathsMap).forEach(({ relativePath, isDirectory }, path) => {\n      if (!isDirectory) return;\n\n      const isChildOfRoot = isChildOrEqual(projectConfig.root, relativePath);\n      const relativeRootConfig = projectConfig.sourceRoot\n        ? relative(workspacePath, projectConfig.sourceRoot)\n        : undefined;\n      const isChildOfRootConfig =\n        relativeRootConfig && isChildOrEqual(relativeRootConfig, relativePath);\n\n      if (isChildOfRoot || isChildOfRootConfig) {\n        foundProjects.set(path, projectConfig);\n        pathsMap.delete(path);\n      }\n    });\n\n    // iterate over the project files once and find all the paths that match\n    const nonDirectoryPaths = [...pathsMap.entries()].filter(\n      ([_, { isDirectory }]) => !isDirectory\n    );\n    projectConfig.files?.forEach(({ file }) => {\n      for (const [path, { relativePath }] of nonDirectoryPaths) {\n        if (normalize(file) === normalize(relativePath)) {\n          foundProjects.set(path, projectConfig);\n          pathsMap.delete(path);\n        }\n      }\n    });\n\n    if (pathsMap.size === 0) {\n      break;\n    }\n  }\n\n  return Object.fromEntries(foundProjects);\n}\n\n/** This is only used for backwards compatibility  */\nfunction findByFilePath(\n  entry: [string, ProjectConfiguration] | undefined,\n  workspacePath: string,\n  selectedPath: string\n) {\n  if (!entry) {\n    return null;\n  }\n\n  let perfectMatchEntry: [string, ProjectConfiguration] | undefined;\n  let secondaryMatchEntry: [string, ProjectConfiguration] | undefined;\n\n  const [, projectConfiguration] = entry;\n  const fullProjectPath = join(\n    workspacePath,\n    // If root is empty, that means we're in an angular project with the old ng workspace setup. Otherwise use the sourceRoot\n    projectConfiguration.root || projectConfiguration.sourceRoot || ''\n  );\n  if (fullProjectPath === selectedPath) {\n    perfectMatchEntry = entry;\n  }\n\n  const relativePath = relative(fullProjectPath, selectedPath);\n  if (\n    relativePath &&\n    !relativePath.startsWith('..') &&\n    !isAbsolute(relativePath)\n  ) {\n    secondaryMatchEntry = entry;\n  }\n\n  entry = perfectMatchEntry ?? secondaryMatchEntry;\n\n  return entry ? { name: entry[0], ...entry[1] } : null;\n}\n\nfunction isChildOrEqual(parent: string, child: string) {\n  const p = parent.endsWith(sep) ? parent : parent + sep;\n  const c = child.endsWith(sep) ? child : child + sep;\n  return normalize(c).startsWith(normalize(p));\n}\n","import { Option } from './schema';\n\nexport function isProjectOption(option: Option) {\n  return (\n    option.name === 'project' ||\n    option.name === 'projectName' ||\n    option.$default?.$source === 'projectName' ||\n    option['x-dropdown'] === 'projects'\n  );\n}\n","import {\n  clearJsonCache,\n  readAndCacheJsonFile,\n} from '@nx-console/shared/file-system';\nimport {\n  packageDetails,\n  workspaceDependencies,\n  workspaceDependencyPath,\n} from '@nx-console/shared/npm';\nimport {\n  CollectionInfo,\n  ExecutorCollectionInfo,\n  Generator,\n  GeneratorCollectionInfo,\n  GeneratorType,\n} from '@nx-console/shared/schema';\nimport { platform } from 'os';\nimport { dirname, resolve } from 'path';\nimport { nxWorkspace } from './workspace';\n\nexport type ReadCollectionsOptions = {\n  clearPackageJsonCache?: boolean;\n  includeHidden?: boolean;\n  includeNgAdd?: boolean;\n};\n\nexport async function readCollections(\n  workspacePath: string,\n  options: ReadCollectionsOptions\n): Promise<CollectionInfo[]> {\n  if (options?.clearPackageJsonCache) {\n    clearJsonCache('package.json', workspacePath);\n  }\n\n  const {\n    workspace: { projects },\n    nxVersion,\n  } = await nxWorkspace(workspacePath);\n\n  const packages = await workspaceDependencies(\n    workspacePath,\n    nxVersion,\n    projects\n  );\n\n  const collections = await Promise.all(\n    packages.map(async (p) => {\n      return await packageDetails(p);\n    })\n  );\n\n  const allCollections = (\n    await Promise.all(\n      collections.map((c) => readCollection(workspacePath, c, options))\n    )\n  ).flat();\n\n  /**\n   * Since we gather all collections, and collections listed in `extends`, we need to dedupe collections here if workspaces have that extended collection in their own package.json\n   */\n  const dedupedCollections = new Map<string, CollectionInfo>();\n  for (const singleCollection of allCollections) {\n    if (!singleCollection) {\n      continue;\n    }\n\n    if (\n      !dedupedCollections.has(\n        collectionNameWithType(singleCollection.name, singleCollection.type)\n      )\n    ) {\n      dedupedCollections.set(\n        collectionNameWithType(singleCollection.name, singleCollection.type),\n        singleCollection\n      );\n    }\n  }\n\n  return Array.from(dedupedCollections.values());\n}\n\nasync function readCollection(\n  workspacePath: string,\n  {\n    packagePath,\n    packageName,\n    packageJson: json,\n  }: {\n    packagePath: string;\n    packageName: string;\n    packageJson: any;\n  },\n  options: ReadCollectionsOptions\n): Promise<CollectionInfo[] | null> {\n  try {\n    const [executorCollections, generatorCollections] = await Promise.all([\n      readAndCacheJsonFile(json.executors || json.builders, packagePath),\n      readAndCacheJsonFile(json.generators || json.schematics, packagePath),\n    ]);\n\n    return getCollectionInfo(\n      workspacePath,\n      packageName,\n      packagePath,\n      executorCollections,\n      generatorCollections,\n      options\n    );\n  } catch (e) {\n    return null;\n  }\n}\n\nexport async function getCollectionInfo(\n  workspacePath: string,\n  collectionName: string,\n  collectionPath: string,\n  executorCollection: { path: string; json: any },\n  generatorCollection: { path: string; json: any },\n  options: ReadCollectionsOptions\n): Promise<CollectionInfo[]> {\n  const collectionMap: Map<string, CollectionInfo> = new Map();\n\n  const executors = {\n    ...executorCollection.json.executors,\n    ...executorCollection.json.builders,\n  };\n  for (const [key, schema] of Object.entries<any>(executors)) {\n    if (!canUse(key, schema, options.includeHidden, options.includeNgAdd)) {\n      continue;\n    }\n    const collectionInfo: ExecutorCollectionInfo = {\n      type: 'executor',\n      name: `${collectionName}:${key}`,\n      schemaPath: formatCollectionPath(\n        collectionPath,\n        executorCollection.path,\n        schema.schema\n      ),\n      implementationPath: formatCollectionPath(\n        collectionPath,\n        executorCollection.path,\n        schema.implementation\n      ),\n      configPath: formatPath(resolve(collectionPath, executorCollection.path)),\n    };\n    if (\n      collectionMap.has(collectionNameWithType(collectionInfo.name, 'executor'))\n    ) {\n      continue;\n    }\n    collectionMap.set(\n      collectionNameWithType(collectionInfo.name, 'executor'),\n      collectionInfo\n    );\n  }\n\n  const generators = {\n    ...generatorCollection.json.generators,\n    ...generatorCollection.json.schematics,\n  };\n  for (const [key, schema] of Object.entries<any>(generators)) {\n    if (!canUse(key, schema, options.includeHidden, options.includeNgAdd)) {\n      continue;\n    }\n\n    try {\n      const collectionInfo: GeneratorCollectionInfo = {\n        type: 'generator',\n        name: `${collectionName}:${key}`,\n        schemaPath: formatCollectionPath(\n          collectionPath,\n          generatorCollection.path,\n          schema.schema\n        ),\n        configPath: formatPath(\n          resolve(collectionPath, generatorCollection.path)\n        ),\n        data: readCollectionGenerator(collectionName, key, schema),\n      };\n      if (\n        collectionMap.has(\n          collectionNameWithType(collectionInfo.name, 'generator')\n        )\n      ) {\n        continue;\n      }\n      collectionMap.set(\n        collectionNameWithType(collectionInfo.name, 'generator'),\n        collectionInfo\n      );\n    } catch (e) {\n      // noop - generator is invalid\n    }\n  }\n\n  if (\n    generatorCollection.json.extends &&\n    Array.isArray(generatorCollection.json.extends)\n  ) {\n    const extendedSchema = generatorCollection.json.extends as string[];\n    const extendedCollections = (\n      await Promise.all(\n        extendedSchema\n          .filter(\n            (extended) =>\n              extended !== '@nx/workspace' && extended !== '@nrwl/workspace'\n          )\n          .map(async (extended: string) => {\n            const dependencyPath = await workspaceDependencyPath(\n              workspacePath,\n              extended\n            );\n\n            if (!dependencyPath) {\n              return null;\n            }\n\n            return readCollection(\n              workspacePath,\n              await packageDetails(dependencyPath),\n              options\n            );\n          })\n      )\n    )\n      .flat()\n      .filter((c): c is CollectionInfo => Boolean(c));\n\n    for (const collection of extendedCollections) {\n      if (collectionMap.has(collection.name)) {\n        continue;\n      }\n\n      collectionMap.set(collection.name, collection);\n    }\n  }\n\n  return Array.from(collectionMap.values());\n}\n\nfunction readCollectionGenerator(\n  collectionName: string,\n  collectionSchemaName: string,\n  collectionJson: any\n): Generator | undefined {\n  try {\n    let generatorType: GeneratorType;\n    switch (collectionJson['x-type']) {\n      case 'application':\n        generatorType = GeneratorType.Application;\n        break;\n      case 'library':\n        generatorType = GeneratorType.Library;\n        break;\n      default:\n        generatorType = GeneratorType.Other;\n        break;\n    }\n    return {\n      name: collectionSchemaName,\n      collection: collectionName,\n      description: collectionJson.description || '',\n      aliases: collectionJson.aliases ?? [],\n      type: generatorType,\n    };\n  } catch (e) {\n    console.error(e);\n    console.error(\n      `Invalid package.json for schematic ${collectionName}:${collectionSchemaName}`\n    );\n  }\n}\n\n/**\n * Checks to see if the collection is usable within Nx Console.\n * @param name\n * @param s\n * @returns\n */\nfunction canUse(\n  name: string,\n  s: {\n    hidden: boolean;\n    private: boolean;\n    schema: string;\n    extends: boolean;\n    'x-deprecated'?: string;\n  },\n  includeHiddenCollections = false,\n  includeNgAddCollection = false\n): boolean {\n  return (\n    (!s.hidden || includeHiddenCollections) &&\n    !s.private &&\n    !s.extends &&\n    !s['x-deprecated'] &&\n    (name !== 'ng-add' || includeNgAddCollection)\n  );\n}\n\nfunction collectionNameWithType(name: string, type: 'generator' | 'executor') {\n  return `${name}-${type}`;\n}\n\nfunction formatCollectionPath(\n  collectionPath: string,\n  jsonFilePath: string,\n  path: string\n): string {\n  return formatPath(resolve(collectionPath, dirname(jsonFilePath), path));\n}\n\nfunction formatPath(path: string): string {\n  if (platform() === 'win32') {\n    return `file:///${path.replace(/\\\\/g, '/')}`;\n  }\n\n  return path;\n}\n","import { ExecutorCollectionInfo } from '@nx-console/shared/schema';\nimport { readCollections } from './read-collections';\n\nexport type GetExecutorsOptions = {\n  includeHidden: boolean;\n  clearPackageJsonCache: boolean;\n};\n\nexport async function getExecutors(\n  workspacePath: string,\n  options: GetExecutorsOptions = {\n    includeHidden: false,\n    clearPackageJsonCache: false,\n  }\n): Promise<ExecutorCollectionInfo[]> {\n  return (\n    await readCollections(workspacePath, {\n      clearPackageJsonCache: options.clearPackageJsonCache,\n      includeHidden: options.includeHidden,\n    })\n  ).filter(\n    (collection): collection is ExecutorCollectionInfo =>\n      collection.type === 'executor'\n  );\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.array.reduce.js\");","import { CollectionInfo } from '@nx-console/shared/schema';\nimport { platform } from 'os';\nimport { JSONSchema } from 'vscode-json-languageservice';\n\ntype BuildersSchema = JSONSchema;\ntype ExecutorsSchema = JSONSchema;\n\n/**\n * Builds the schema for builders and executors.\n *\n * @param collections\n * @returns [BuildersSchema[], ExecutorsSchema[]]\n */\nexport function createBuildersAndExecutorsSchema(\n  collections: CollectionInfo[]\n): [BuildersSchema[], ExecutorsSchema[]] {\n  return collections.reduce<[BuildersSchema[], ExecutorsSchema[]]>(\n    (acc, collection) => {\n      const schemaRef =\n        platform() === 'win32'\n          ? collection.schemaPath\n          : `file://${collection.schemaPath}`;\n\n      acc[0].push({\n        if: {\n          properties: { builder: { const: collection.name } },\n          required: ['builder'],\n        },\n        then: {\n          properties: {\n            options: {\n              $ref: schemaRef,\n            },\n            configurations: {\n              additionalProperties: {\n                $ref: schemaRef,\n                required: [],\n              },\n            },\n          },\n        },\n      });\n      acc[1].push({\n        if: {\n          properties: { executor: { const: collection.name } },\n          required: ['executor'],\n        },\n        then: {\n          properties: {\n            options: {\n              $ref: schemaRef,\n            },\n            configurations: {\n              additionalProperties: {\n                $ref: schemaRef,\n                required: [],\n              },\n            },\n          },\n        },\n      });\n      return acc;\n    },\n    [[], []]\n  );\n}\n","import { hasKey } from '@nx-console/shared/utils';\nimport { JSONSchema } from 'vscode-json-languageservice';\n\nexport const X_COMPLETION_TYPE = 'x-completion-type' as const;\nexport const X_COMPLETION_GLOB = 'x-completion-glob' as const;\n\nexport enum CompletionType {\n  file = 'file',\n  directory = 'directory',\n  // support for projectName:build auto complete\n  projectTarget = 'projectTarget',\n  projects = 'projects',\n  targets = 'targets',\n  // support for target with ^ (^build, build, etc)\n  targetsWithDeps = 'targetsWithDeps',\n  tags = 'tags',\n  inputName = 'inputName',\n  // support for input names with ^ (^production, production, etc)\n  inputNameWithDeps = 'inputNameWithDeps',\n}\n\nexport function hasCompletionType(\n  schema: JSONSchema\n): schema is JSONSchema & { [X_COMPLETION_TYPE]: CompletionType } {\n  return hasKey(schema, X_COMPLETION_TYPE);\n}\n\nexport function hasCompletionGlob(\n  schema: JSONSchema\n): schema is JSONSchema & { [X_COMPLETION_GLOB]: string } {\n  return hasKey(schema, X_COMPLETION_GLOB);\n}\n\ndeclare module 'vscode-json-languageservice' {\n  interface JSONSchema {\n    [X_COMPLETION_TYPE]?: CompletionType;\n    [X_COMPLETION_GLOB]?: string;\n  }\n}\n\nexport type EnhancedJsonSchema = JSONSchema;\n","import { JSONSchema } from 'vscode-json-languageservice';\nimport { CompletionType } from './completion-type';\nimport { NxVersion } from '@nx-console/shared/types';\n\nexport const implicitDependencies: JSONSchema = {\n  type: 'array',\n  items: {\n    type: 'string',\n    'x-completion-type': CompletionType.projects,\n  },\n};\n\nexport const outputs: JSONSchema = {\n  type: 'array',\n  items: {\n    type: 'string',\n    'x-completion-type': CompletionType.directory,\n  },\n};\n\nexport const inputs = (nxVersion: NxVersion): JSONSchema[] => [\n  { type: 'string', 'x-completion-type': CompletionType.inputNameWithDeps },\n  {\n    type: 'object',\n    properties: {\n      input: {\n        type: 'string',\n        'x-completion-type': CompletionType.inputName,\n      },\n      projects: projects(nxVersion),\n    },\n  },\n  {\n    type: 'object',\n    properties: {\n      fileset: {\n        type: 'string',\n      },\n    },\n  },\n  {\n    type: 'object',\n    properties: {\n      runtime: {\n        type: 'string',\n      },\n    },\n  },\n  {\n    type: 'object',\n    properties: {\n      env: {\n        type: 'string',\n      },\n    },\n  },\n];\n\nexport const namedInputs = (nxVersion: NxVersion): JSONSchema => ({\n  type: 'object',\n  additionalProperties: {\n    oneOf: inputs(nxVersion),\n  },\n});\n\nexport const tags: JSONSchema = {\n  type: 'array',\n  items: {\n    type: 'string',\n    'x-completion-type': CompletionType.tags,\n  },\n};\n\nconst projects = (nxVersion: NxVersion): JSONSchema => {\n  if (nxVersion.major < 16) {\n    return {\n      type: 'string',\n      enum: ['self', 'dependencies'],\n    };\n  } else {\n    return {\n      oneOf: [\n        {\n          type: 'string',\n          'x-completion-type': CompletionType.projects,\n        },\n        {\n          type: 'array',\n          items: {\n            type: 'string',\n            'x-completion-type': CompletionType.projects,\n          },\n        },\n      ],\n    };\n  }\n};\n\nexport const targets = (\n  nxVersion: NxVersion,\n  executors?: JSONSchema[]\n): JSONSchema => {\n  const schema: JSONSchema = {\n    additionalProperties: {\n      type: 'object',\n      properties: {\n        outputs,\n        ...(executors && { executor: { type: 'string' } }),\n        ...(executors && {\n          configurations: { additionalProperties: { type: 'object' } },\n        }),\n        dependsOn: {\n          type: 'array',\n          items: {\n            oneOf: [\n              {\n                type: 'string',\n                'x-completion-type': CompletionType.targetsWithDeps,\n              },\n              {\n                type: 'object',\n                properties: {\n                  projects: projects(nxVersion),\n                  target: {\n                    type: 'string',\n                    'x-completion-type': CompletionType.targets,\n                  },\n                  params: {\n                    type: 'string',\n                    enum: ['ignore', 'forward'],\n                  },\n                },\n              },\n            ],\n          },\n        },\n        inputs: {\n          type: 'array',\n          items: {\n            oneOf: inputs(nxVersion),\n          },\n        },\n      },\n      ...(executors && { allOf: executors }),\n    },\n  };\n\n  return schema;\n};\n","import { TargetConfiguration } from 'nx/src/devkit-exports';\nimport { CollectionInfo } from '@nx-console/shared/schema';\nimport { TargetDefaults } from 'nx/src/config/nx-json';\nimport type { JSONSchema } from 'vscode-json-languageservice';\nimport {\n  implicitDependencies,\n  namedInputs,\n  tags,\n  targets,\n} from './common-json-schema';\nimport { CompletionType, EnhancedJsonSchema } from './completion-type';\nimport { createBuildersAndExecutorsSchema } from './create-builders-and-executors-schema';\nimport { NxVersion } from '@nx-console/shared/types';\n\ntype JSONSchemaMap = NonNullable<JSONSchema['properties']>;\n\nexport function getProjectJsonSchema(\n  collections: CollectionInfo[],\n  targetDefaults: TargetDefaults = {},\n  nxVersion: NxVersion\n) {\n  const [, executors] = createBuildersAndExecutorsSchema(collections);\n  const contents = createJsonSchema(executors, targetDefaults, nxVersion);\n  return contents;\n}\n\nfunction createJsonSchema(\n  executors: JSONSchema[],\n  targetDefaults: TargetDefaults,\n  nxVersion: NxVersion\n): EnhancedJsonSchema {\n  const targetsSchema =\n    (targets(nxVersion, executors).additionalProperties as object) ?? {};\n  const targetsProperties = Object.keys(targetDefaults)\n    .filter(\n      (target) =>\n        !(\n          target.includes('@') &&\n          target.includes('/') &&\n          target.includes(':')\n        ) &&\n        target !== 'nx:run-commands' &&\n        target !== 'nx:run-script' &&\n        target !== 'nx:noop'\n    )\n    .reduce<JSONSchemaMap>((targets, target) => {\n      const defaults: Partial<TargetConfiguration> = targetDefaults[target];\n      let targetSchema: JSONSchema = targetsSchema;\n      if (defaults?.executor) {\n        const match = executors.find((schema) => {\n          const test = schema.if as JSONSchema;\n          const executor = test?.properties?.executor as JSONSchema;\n          return executor?.const === defaults.executor;\n        });\n        if (match) {\n          targetSchema = {\n            if: {\n              properties: { executor: { type: 'string' } },\n              required: ['executor'],\n            },\n            then: targetsSchema,\n            else: match.then,\n          };\n        }\n      }\n      targets[target] = targetSchema;\n      return targets;\n    }, {});\n  return {\n    type: 'object',\n    properties: {\n      sourceRoot: {\n        type: 'string',\n        'x-completion-type': CompletionType.directory,\n      },\n      implicitDependencies,\n      tags,\n      namedInputs: namedInputs(nxVersion),\n      targets: {\n        type: 'object',\n        properties: targetsProperties,\n        additionalProperties: targetsSchema,\n      },\n    },\n  };\n}\n","import { NxVersion } from '@nx-console/shared/types';\nimport {\n  implicitDependencies,\n  namedInputs,\n  tags,\n  targets,\n} from './common-json-schema';\nimport { EnhancedJsonSchema } from './completion-type';\n\nexport function getPackageJsonSchema(nxVersion: NxVersion) {\n  const contents = createJsonSchema(nxVersion);\n  return contents;\n}\n\nfunction createJsonSchema(nxVersion: NxVersion): EnhancedJsonSchema {\n  return {\n    type: 'object',\n    properties: {\n      nx: {\n        type: 'object',\n        properties: {\n          ignore: {\n            type: 'boolean',\n          },\n          namedInputs: namedInputs(nxVersion),\n          tags,\n          implicitDependencies,\n          targets: targets(nxVersion),\n        },\n      },\n    },\n  };\n}\n","import { CollectionInfo } from '@nx-console/shared/schema';\nimport type { ProjectConfiguration } from 'nx/src/devkit-exports';\nimport type { JSONSchema } from 'vscode-json-languageservice';\nimport { targets } from './common-json-schema';\nimport { CompletionType, EnhancedJsonSchema } from './completion-type';\nimport { createBuildersAndExecutorsSchema } from './create-builders-and-executors-schema';\nimport { NxVersion } from '@nx-console/shared/types';\n\ntype JSONSchemaMap = NonNullable<JSONSchema['properties']>;\n\nexport function getNxJsonSchema(\n  collections: CollectionInfo[],\n  projects: Record<string, ProjectConfiguration>,\n  nxVersion: NxVersion\n) {\n  const [, executors] = createBuildersAndExecutorsSchema(collections);\n  const targets = getTargets(projects);\n  const contents = createJsonSchema(executors, targets, nxVersion);\n  return contents;\n}\n\nfunction createJsonSchema(\n  executors: JSONSchema[],\n  projectTargets: string[],\n  nxVersion: NxVersion\n): EnhancedJsonSchema {\n  const targetsSchema =\n    (targets(nxVersion, executors).additionalProperties as object) ?? {};\n  return {\n    type: 'object',\n    properties: {\n      tasksRunnerOptions: {\n        type: 'object',\n        additionalProperties: {\n          type: 'object',\n          properties: {\n            options: {\n              type: 'object',\n              properties: {\n                cacheableOperations: {\n                  type: 'array',\n                  items: {\n                    type: 'string',\n                    'x-completion-type': CompletionType.targets,\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n      targetDefaults: {\n        type: 'object',\n        properties: projectTargets.reduce<JSONSchemaMap>((acc, current) => {\n          acc[current] = {\n            type: 'object',\n            ...targetsSchema,\n          };\n          return acc;\n        }, {}),\n      },\n      targetDependencyConfig: {\n        type: 'array',\n        items: {\n          oneOf: [\n            {\n              type: 'string',\n              'x-completion-type': CompletionType.targetsWithDeps,\n            },\n            {\n              type: 'object',\n              properties: {\n                target: {\n                  type: 'string',\n                  description: 'The name of the target.',\n                  'x-completion-type': CompletionType.targets,\n                },\n              },\n            },\n          ],\n        },\n      },\n    },\n  };\n}\n\nfunction getTargets(projects: Record<string, ProjectConfiguration>): string[] {\n  const tags = new Set<string>();\n\n  for (const projectConfiguration of Object.values(projects)) {\n    for (const target of Object.keys(projectConfiguration.targets ?? {})) {\n      tags.add(target);\n    }\n  }\n\n  return Array.from(tags);\n}\n","import {\n  configureJsonLanguageService,\n  getSchemaRequestService,\n  lspLogger,\n} from '@nx-console/language-server/utils';\nimport {\n  getExecutors,\n  getProjectByRoot,\n  nxWorkspace,\n} from '@nx-console/language-server/workspace';\nimport {\n  CompletionType,\n  getNxJsonSchema,\n  getPackageJsonSchema,\n  getProjectJsonSchema,\n  getWorkspaceJsonSchema,\n  implicitDependencies,\n  namedInputs,\n  tags,\n} from '@nx-console/shared/json-schema';\nimport { CollectionInfo } from '@nx-console/shared/schema';\nimport { NxWorkspace } from '@nx-console/shared/types';\nimport { platform } from 'os';\nimport { join } from 'path';\nimport {\n  ClientCapabilities,\n  SchemaConfiguration,\n} from 'vscode-json-languageservice';\n\nlet currentBaseSchemas: SchemaConfiguration[] = [];\nlet currentExecutors: CollectionInfo[] | undefined;\nlet currentNxWorkspace: NxWorkspace | undefined;\n\nexport async function configureSchemas(\n  workingPath: string | undefined,\n  workspaceContext: {\n    resolveRelativePath: (relativePath: string, resource: string) => string;\n  },\n  capabilities: ClientCapabilities | undefined\n) {\n  if (!workingPath) {\n    lspLogger.log('No workspace path provided');\n    return;\n  }\n\n  currentNxWorkspace = await nxWorkspace(workingPath, lspLogger);\n  const { nxVersion, workspace } = currentNxWorkspace;\n\n  currentExecutors = await getExecutors(workingPath);\n  const workspaceJsonSchema = getWorkspaceJsonSchema(currentExecutors);\n  const projectJsonSchema = getProjectJsonSchema(\n    currentExecutors,\n    workspace.targetDefaults,\n    nxVersion\n  );\n  const packageJsonSchema = getPackageJsonSchema(nxVersion);\n\n  const nxSchema = getNxJsonSchema(\n    currentExecutors,\n    workspace.projects,\n    nxVersion\n  );\n\n  currentBaseSchemas = [\n    {\n      uri: 'nx://schemas/workspace',\n      fileMatch: ['**/workspace.json'],\n      schema: workspaceJsonSchema,\n    },\n    {\n      uri: 'nx://schemas/project',\n      fileMatch: ['**/project.json'],\n      schema: projectJsonSchema,\n    },\n    {\n      uri: 'nx://schemas/package',\n      fileMatch: ['**/package.json'],\n      schema: packageJsonSchema,\n    },\n    {\n      uri: 'nx://schemas/nx',\n      fileMatch: ['**/nx.json'],\n      schema: nxSchema,\n    },\n  ];\n\n  // recalculate project-specific schemas\n  for (const key in projectSchemas.keys()) {\n    const projectSchema = await getProjectSchema(key, workingPath);\n    if (!projectSchema) {\n      continue;\n    }\n    projectSchemas.set(key, projectSchema);\n  }\n  _configureJsonLanguageService(\n    workspaceContext,\n    capabilities,\n    getProjectSchemas(),\n    currentBaseSchemas\n  );\n}\n\nconst projectSchemas: Map<string, SchemaConfiguration> = new Map();\n\nexport function projectSchemaIsRegistered(projectRoot: string): boolean {\n  return projectSchemas.has(projectRoot);\n}\n\nfunction getProjectSchemas(): SchemaConfiguration[] {\n  return Array.from(projectSchemas.values());\n}\n\n/**\n * Configures the language server with a new schema for the current project.\n * This will reuse workspace info set by `configureSchemas` if available\n */\nexport async function configureSchemaForProject(\n  projectRootPath: string,\n  workingPath: string | undefined,\n  workspaceContext: {\n    resolveRelativePath: (relativePath: string, resource: string) => string;\n  },\n  capabilities: ClientCapabilities | undefined\n) {\n  const projectSchema = await getProjectSchema(projectRootPath, workingPath);\n  if (!projectSchema) {\n    return;\n  }\n\n  projectSchemas.set(projectRootPath, projectSchema);\n\n  _configureJsonLanguageService(\n    workspaceContext,\n    capabilities,\n    getProjectSchemas(),\n    currentBaseSchemas\n  );\n}\n\nasync function getProjectSchema(\n  projectRootPath: string,\n  workingPath: string | undefined\n): Promise<SchemaConfiguration | undefined> {\n  if (!workingPath) {\n    lspLogger.log(\n      `No workspace path provided when configuring schema for ${projectRootPath}`\n    );\n    return;\n  }\n  if (!currentNxWorkspace) {\n    currentNxWorkspace = await nxWorkspace(workingPath, lspLogger);\n  }\n  if (!currentExecutors) {\n    currentExecutors = await getExecutors(workingPath);\n  }\n\n  const project = await getProjectByRoot(projectRootPath, workingPath);\n  if (!project) {\n    return;\n  }\n\n  const { nxVersion } = currentNxWorkspace;\n\n  const targetsProperties: Record<string, any> = {};\n  Object.entries(project.targets ?? {}).forEach(([key, target]) => {\n    const executor = target.executor ?? 'nx:run-commands';\n    const matchingCollection = currentExecutors?.find(\n      (e) => e.name === executor\n    );\n    if (!matchingCollection) {\n      return;\n    }\n    const schemaRef =\n      platform() === 'win32'\n        ? matchingCollection.schemaPath\n        : `file://${matchingCollection.schemaPath}`;\n\n    targetsProperties[key] = {\n      properties: {\n        options: {\n          $ref: schemaRef,\n        },\n        configurations: {\n          additionalProperties: {\n            $ref: schemaRef,\n            required: [],\n          },\n        },\n      },\n    };\n  });\n\n  return {\n    uri: `nx://schemas/project-${project.name}`,\n    fileMatch: [join(workingPath, projectRootPath, 'project.json')],\n    schema: {\n      type: 'object',\n      properties: {\n        sourceRoot: {\n          type: 'string',\n          'x-completion-type': CompletionType.directory,\n        },\n        implicitDependencies,\n        tags,\n        namedInputs: namedInputs(nxVersion),\n        targets: {\n          type: 'object',\n          properties: targetsProperties,\n        },\n      },\n    },\n  };\n}\n\nfunction _configureJsonLanguageService(\n  workspaceContext: {\n    resolveRelativePath: (relativePath: string, resource: string) => string;\n  },\n  capabilities: ClientCapabilities | undefined,\n  projectSchemas: SchemaConfiguration[],\n  baseSchemas: SchemaConfiguration[]\n) {\n  configureJsonLanguageService(\n    {\n      schemaRequestService: getSchemaRequestService(['file']),\n      workspaceContext,\n      contributions: [],\n      clientCapabilities: capabilities,\n    },\n    {\n      schemas: [...projectSchemas, ...baseSchemas],\n    }\n  );\n}\n","import { CollectionInfo } from '@nx-console/shared/schema';\nimport { JSONSchema } from 'vscode-json-languageservice';\nimport { createBuildersAndExecutorsSchema } from './create-builders-and-executors-schema';\n\nexport function getWorkspaceJsonSchema(collections: CollectionInfo[]) {\n  const [builders, executors] = createBuildersAndExecutorsSchema(collections);\n  const contents = createJsonSchema(builders, executors);\n  return contents;\n}\n\nfunction createJsonSchema(\n  builders: JSONSchema[],\n  executors: JSONSchema[]\n): JSONSchema {\n  return {\n    title: 'JSON schema for Nx workspaces',\n    id: 'https://nx.dev',\n    type: 'object',\n    properties: {\n      version: {\n        type: 'number',\n        enum: [1, 2],\n      },\n    },\n    allOf: [\n      {\n        if: {\n          properties: { version: { const: 1 } },\n          required: ['version'],\n        },\n        then: {\n          properties: {\n            projects: {\n              type: 'object',\n              additionalProperties: {\n                type: 'object',\n                properties: {\n                  architect: {\n                    description:\n                      'Configures all the targets which define what tasks you can run against the project',\n                    additionalProperties: {\n                      type: 'object',\n                      properties: {\n                        builder: {\n                          description:\n                            'The function that Nx will invoke when you run this architect',\n                          type: 'string',\n                        },\n                        options: {\n                          type: 'object',\n                        },\n                        configurations: {\n                          description:\n                            'provides extra sets of values that will be merged into the options map',\n                          additionalProperties: {\n                            type: 'object',\n                          },\n                        },\n                      },\n                      allOf: builders,\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n      {\n        if: {\n          properties: { version: { const: 2 } },\n          required: ['version'],\n        },\n        then: {\n          properties: {\n            projects: {\n              type: 'object',\n              additionalProperties: {\n                oneOf: [\n                  {\n                    type: 'string',\n                  },\n                  {\n                    type: 'object',\n                    properties: {\n                      targets: {\n                        description:\n                          'Configures all the targets which define what tasks you can run against the project',\n                        additionalProperties: {\n                          type: 'object',\n                          properties: {\n                            executor: {\n                              description:\n                                'The function that Nx will invoke when you run this target',\n                              type: 'string',\n                            },\n                            options: {\n                              type: 'object',\n                            },\n                            configurations: {\n                              description:\n                                'provides extra sets of values that will be merged into the options map',\n                              additionalProperties: {\n                                type: 'object',\n                              },\n                            },\n                          },\n                          allOf: executors,\n                        },\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n          },\n        },\n      },\n    ],\n  };\n}\n","import {\n  ArrayASTNode,\n  ASTNode,\n  ObjectASTNode,\n  PropertyASTNode,\n  StringASTNode,\n} from 'vscode-json-languageservice';\n\nexport function isPropertyNode(node?: ASTNode): node is PropertyASTNode {\n  return node?.type === 'property';\n}\n\nexport function isObjectNode(node?: ASTNode): node is ObjectASTNode {\n  return node?.type === 'object';\n}\n\nexport function isStringNode(node?: ASTNode): node is StringASTNode {\n  return node?.type === 'string';\n}\n\nexport function isArrayNode(node?: ASTNode): node is ArrayASTNode {\n  return node?.type === 'array';\n}\n","import { CompletionType } from '@nx-console/shared/json-schema';\nimport { ASTNode } from 'vscode-json-languageservice';\nimport { isPropertyNode, isStringNode } from './node-types';\n\ntype DefaultCompletion = { glob?: string; completionType: CompletionType };\n\nconst defaultCompletionMap = new Map<string, DefaultCompletion>();\n\ndefaultCompletionMap.set('jestconfig', {\n  glob: 'jest.config.@(js|ts)',\n  completionType: CompletionType.file,\n});\ndefaultCompletionMap.set('index', {\n  glob: '*.html',\n  completionType: CompletionType.file,\n});\ndefaultCompletionMap.set('polyfills', {\n  glob: '*.ts',\n  completionType: CompletionType.file,\n});\ndefaultCompletionMap.set('main', {\n  glob: '*.ts',\n  completionType: CompletionType.file,\n});\ndefaultCompletionMap.set('tsconfig', {\n  glob: 'tsconfig.*.json',\n  completionType: CompletionType.file,\n});\ndefaultCompletionMap.set('outputpath', {\n  completionType: CompletionType.directory,\n});\ndefaultCompletionMap.set('browsertarget', {\n  completionType: CompletionType.projectTarget,\n});\ndefaultCompletionMap.set('servertarget', {\n  completionType: CompletionType.projectTarget,\n});\ndefaultCompletionMap.set('buildtarget', {\n  completionType: CompletionType.projectTarget,\n});\ndefaultCompletionMap.set('target', {\n  completionType: CompletionType.projectTarget,\n});\ndefaultCompletionMap.set('devservertarget', {\n  completionType: CompletionType.projectTarget,\n});\n\nexport function getDefaultCompletionType(\n  node: ASTNode\n): DefaultCompletion | undefined {\n  const parent = node.parent;\n  if (isPropertyNode(parent) && isStringNode(parent.keyNode)) {\n    const key = parent.keyNode.value.toLowerCase();\n    return defaultCompletionMap.get(key);\n  }\n\n  return undefined;\n}\n\nexport function hasDefaultCompletionType(node: ASTNode): boolean {\n  const parent = node.parent;\n  if (isPropertyNode(parent) && isStringNode(parent.keyNode)) {\n    const key = parent.keyNode.value.toLowerCase();\n    return defaultCompletionMap.has(key);\n  }\n\n  return false;\n}\n","import {\n  ASTNode,\n  CompletionItem,\n  CompletionItemKind,\n  TextDocument,\n} from 'vscode-json-languageservice';\n\nexport function createCompletionItem(\n  label: string,\n  path: string,\n  node: ASTNode,\n  document: TextDocument,\n  kind: CompletionItemKind,\n  documentation?: string\n): CompletionItem {\n  const startPosition = document.positionAt(node.offset);\n  const endPosition = document.positionAt(node.offset + node.length);\n  label = `\"${label}\"`;\n  return {\n    label,\n    documentation,\n    kind,\n    insertText: label,\n    insertTextFormat: 2,\n    textEdit: {\n      newText: label,\n      range: {\n        start: startPosition,\n        end: endPosition,\n      },\n    },\n    detail: path,\n  };\n}\n","import { nxWorkspace } from '@nx-console/language-server/workspace';\nimport {\n  ASTNode,\n  CompletionItem,\n  CompletionItemKind,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport { createCompletionItem } from './create-completion-path-item';\n\nexport async function inputNameCompletion(\n  workingPath: string | undefined,\n  node: ASTNode,\n  document: TextDocument,\n  hasDependencyHat = false\n): Promise<CompletionItem[]> {\n  if (!workingPath) {\n    return [];\n  }\n\n  const inputNameCompletion: CompletionItem[] = [];\n\n  const { workspace } = await nxWorkspace(workingPath);\n\n  for (const inputName of Object.keys(workspace.namedInputs ?? {})) {\n    if (hasDependencyHat) {\n      inputNameCompletion.push(\n        createCompletionItem(\n          `^${inputName}`,\n          '',\n          node,\n          document,\n          CompletionItemKind.Property,\n          `Base \"${inputName}\" on this project's dependencies`\n        )\n      );\n    }\n    inputNameCompletion.push(\n      createCompletionItem(\n        inputName,\n        '',\n        node,\n        document,\n        CompletionItemKind.Property\n      )\n    );\n  }\n\n  return inputNameCompletion;\n}\n","import { ASTNode } from 'vscode-json-languageservice';\nimport { isObjectNode, isPropertyNode, isStringNode } from './node-types';\n\n/**\n * Get the first `root` property from the current node to determine `${projectRoot}`\n * @param node\n * @returns\n */\nexport function findProjectRoot(node: ASTNode): string {\n  if (isObjectNode(node)) {\n    for (const child of node.children) {\n      if (isPropertyNode(child)) {\n        if (\n          (child.keyNode.value === 'root' ||\n            child.keyNode.value === 'sourceRoot') &&\n          isStringNode(child.valueNode)\n        ) {\n          return child.valueNode?.value;\n        }\n      }\n    }\n  }\n\n  if (node.parent) {\n    return findProjectRoot(node.parent);\n  }\n\n  return '';\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fast-glob\");","import {\n  findProjectRoot,\n  isStringNode,\n} from '@nx-console/language-server/utils';\nimport fastGlob from 'fast-glob';\nimport {\n  ASTNode,\n  CompletionItem,\n  CompletionItemKind,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport { createCompletionItem } from './create-completion-path-item';\n\nexport async function pathCompletion(\n  workingPath: string | undefined,\n  node: ASTNode,\n  document: TextDocument,\n  options?: {\n    glob: string;\n    searchType: 'file' | 'directory';\n    supportsInterpolation?: boolean;\n  }\n): Promise<CompletionItem[]> {\n  const items: CompletionItem[] = [];\n\n  if (!workingPath) {\n    return items;\n  }\n\n  const { supportsInterpolation, glob, searchType } = {\n    supportsInterpolation: false,\n    ...options,\n  };\n\n  if (!isStringNode(node)) {\n    return items;\n  }\n\n  const projectRoot = findProjectRoot(node);\n\n  const files = await fastGlob([workingPath + '/**/' + glob], {\n    ignore: ['**/node_modules/**'],\n    dot: true,\n    onlyFiles: searchType === 'file',\n    onlyDirectories: searchType === 'directory',\n    objectMode: true,\n  });\n\n  const completionKind =\n    searchType === 'directory'\n      ? CompletionItemKind.Folder\n      : CompletionItemKind.File;\n\n  for (const file of files) {\n    if (\n      supportsInterpolation &&\n      file.path.startsWith(workingPath + '/' + projectRoot)\n    ) {\n      const label =\n        '{projectRoot}' +\n        file.path.replace(workingPath + '/' + projectRoot, '');\n\n      items.push(\n        createCompletionItem(label, file.path, node, document, completionKind)\n      );\n    }\n\n    if (file.path.startsWith(workingPath)) {\n      const label = file.path.replace(workingPath + '/', '');\n\n      if (supportsInterpolation) {\n        const label = '{workspaceRoot}' + file.path.replace(workingPath, '');\n        items.push(\n          createCompletionItem(label, file.path, node, document, completionKind)\n        );\n      } else {\n        items.push(\n          createCompletionItem(label, file.path, node, document, completionKind)\n        );\n      }\n    }\n  }\n\n  return items;\n}\n","import { isArrayNode } from '@nx-console/language-server/utils';\nimport { nxWorkspace } from '@nx-console/language-server/workspace';\nimport {\n  ASTNode,\n  CompletionItem,\n  CompletionItemKind,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport { createCompletionItem } from './create-completion-path-item';\n\nexport async function tagsCompletion(\n  workingPath: string | undefined,\n  node: ASTNode,\n  document: TextDocument\n): Promise<CompletionItem[]> {\n  if (!workingPath) {\n    return [];\n  }\n\n  const tagCompletion: CompletionItem[] = [];\n\n  const { workspace } = await nxWorkspace(workingPath);\n  const tags = new Set<string>();\n  for (const projectConfiguration of Object.values(workspace.projects)) {\n    for (const tag of projectConfiguration.tags ?? []) {\n      tags.add(tag);\n    }\n  }\n\n  const existingTags = getTagsOnCurrentNode(node);\n\n  for (const tag of tags) {\n    if (existingTags.has(tag)) {\n      continue;\n    }\n\n    tagCompletion.push(\n      createCompletionItem(tag, '', node, document, CompletionItemKind.Constant)\n    );\n  }\n\n  return tagCompletion;\n}\n\nfunction getTagsOnCurrentNode(node: ASTNode): Set<string> {\n  const parent = node.parent;\n  if (!isArrayNode(parent)) {\n    return new Set();\n  }\n\n  return new Set(parent.items.map((item) => item.value as string));\n}\n","import { isArrayNode } from '@nx-console/language-server/utils';\nimport { nxWorkspace } from '@nx-console/language-server/workspace';\nimport {\n  ASTNode,\n  CompletionItem,\n  CompletionItemKind,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport { createCompletionItem } from './create-completion-path-item';\n\nexport async function targetsCompletion(\n  workingPath: string | undefined,\n  node: ASTNode,\n  document: TextDocument,\n  hasDependencyHat = false\n): Promise<CompletionItem[]> {\n  if (!workingPath) {\n    return [];\n  }\n\n  const targetsCompletion: CompletionItem[] = [];\n  const { workspace } = await nxWorkspace(workingPath);\n\n  const targetNames = new Set<string>();\n  for (const project of Object.values(workspace.projects)) {\n    for (const targetName of Object.keys(project.targets ?? {})) {\n      targetNames.add(targetName);\n    }\n  }\n\n  const existingTargets = getTargetsOnCurrentNode(node);\n\n  for (const targetName of targetNames) {\n    if (existingTargets.has(targetName)) {\n      continue;\n    }\n\n    if (hasDependencyHat) {\n      const dependencyHat = `^${targetName}`;\n      if (existingTargets.has(dependencyHat)) {\n        continue;\n      }\n\n      targetsCompletion.push(\n        createCompletionItem(\n          dependencyHat,\n          '',\n          node,\n          document,\n          CompletionItemKind.Field,\n          `Run all dependencies that have \"${targetName}\" as a target before this one`\n        )\n      );\n    }\n    targetsCompletion.push(\n      createCompletionItem(\n        targetName,\n        '',\n        node,\n        document,\n        CompletionItemKind.Field\n      )\n    );\n  }\n\n  return targetsCompletion;\n}\n\nfunction getTargetsOnCurrentNode(node: ASTNode) {\n  const parent = node.parent;\n  if (!isArrayNode(parent)) {\n    return new Set();\n  }\n\n  return new Set(parent.items.map((item) => item.value as string));\n}\n","import {\n  CompletionType,\n  hasCompletionGlob,\n  hasCompletionType,\n  X_COMPLETION_GLOB,\n  X_COMPLETION_TYPE,\n} from '@nx-console/shared/json-schema';\nimport {\n  getDefaultCompletionType,\n  isArrayNode,\n} from '@nx-console/language-server/utils';\nimport {\n  ASTNode,\n  CompletionItem,\n  JSONDocument,\n  MatchingSchema,\n  Position,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport { inputNameCompletion } from './input-name-completion';\nimport { pathCompletion } from './path-completion';\nimport { projectCompletion } from './project-completion';\nimport { projectTargetCompletion } from './project-target-completion';\nimport { tagsCompletion } from './tags-completion';\nimport { targetsCompletion } from './targets-completion';\nimport { NxVersion } from '@nx-console/shared/types';\n\nexport async function getCompletionItems(\n  workingPath: string | undefined,\n  nxVersion: NxVersion,\n  jsonAst: JSONDocument,\n  document: TextDocument,\n  schemas: MatchingSchema[],\n  position: Position\n): Promise<CompletionItem[]> {\n  if (!workingPath) {\n    return [];\n  }\n\n  const offset = document.offsetAt(position);\n  const node = jsonAst.getNodeFromOffset(offset);\n  if (!node) {\n    return [];\n  }\n\n  const items = completionItems(workingPath, nxVersion, node, document);\n\n  let resolvedItems: CompletionItem[] = [];\n\n  for (const { schema, node: schemaNode } of schemas) {\n    // Find the schema node that matches the current node\n    // If the node is found, then we will return the whole function so that we don't have to loop over the rest of the items.\n    if (schemaNode == node) {\n      if (hasCompletionType(schema)) {\n        const completion = schema[X_COMPLETION_TYPE];\n        if (hasCompletionGlob(schema)) {\n          resolvedItems = await items(completion, schema[X_COMPLETION_GLOB]);\n          break;\n        }\n\n        resolvedItems = await items(completion);\n        break;\n      }\n    }\n  }\n\n  const defaultCompletion = getDefaultCompletionType(node);\n\n  if (defaultCompletion && resolvedItems.length === 0) {\n    resolvedItems = await items(\n      defaultCompletion.completionType,\n      defaultCompletion.glob\n    );\n  }\n\n  // remove duplicate values from the resolved completed items\n  if (isArrayNode(node.parent)) {\n    const existingItems = node.parent.children.map((i) =>\n      JSON.stringify(i.value)\n    );\n    resolvedItems = resolvedItems.filter(\n      (resolvedItem) => !existingItems.includes(resolvedItem.label)\n    );\n  }\n\n  return resolvedItems;\n}\n\nfunction completionItems(\n  workingPath: string,\n  nxVersion: NxVersion,\n  node: ASTNode,\n  document: TextDocument\n) {\n  return async (\n    completion: CompletionType,\n    glob?: string\n  ): Promise<CompletionItem[]> => {\n    // const supportsInterpolation = nxVersion.major >= 16;\n    // todo(jcammisuli): change this once executors support {workspaceRoot} and {projectRoot} in their options\n    const supportsInterpolation = false;\n    switch (completion) {\n      case CompletionType.file: {\n        return pathCompletion(workingPath, node, document, {\n          glob: glob ?? '*.*',\n          searchType: 'file',\n          supportsInterpolation,\n        });\n      }\n      case CompletionType.directory: {\n        return pathCompletion(workingPath, node, document, {\n          glob: glob ?? '*',\n          searchType: 'directory',\n          supportsInterpolation,\n        });\n      }\n      case CompletionType.projectTarget: {\n        return projectTargetCompletion(workingPath, node, document);\n      }\n      case CompletionType.projects: {\n        return projectCompletion(workingPath, node, document);\n      }\n      case CompletionType.tags: {\n        return tagsCompletion(workingPath, node, document);\n      }\n      case CompletionType.targets: {\n        return targetsCompletion(workingPath, node, document);\n      }\n      case CompletionType.targetsWithDeps: {\n        return targetsCompletion(workingPath, node, document, true);\n      }\n      case CompletionType.inputName: {\n        return inputNameCompletion(workingPath, node, document);\n      }\n      case CompletionType.inputNameWithDeps: {\n        return inputNameCompletion(workingPath, node, document, true);\n      }\n      default: {\n        return [];\n      }\n    }\n  };\n}\n","import { nxWorkspace } from '@nx-console/language-server/workspace';\nimport {\n  ASTNode,\n  CompletionItem,\n  CompletionItemKind,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport { createCompletionItem } from './create-completion-path-item';\n\nexport async function projectTargetCompletion(\n  workingPath: string | undefined,\n  node: ASTNode,\n  document: TextDocument\n): Promise<CompletionItem[]> {\n  if (!workingPath) {\n    return [];\n  }\n\n  const { workspace } = await nxWorkspace(workingPath);\n\n  const projectTargetCompletion: CompletionItem[] = [];\n\n  const completionItemKind = CompletionItemKind.Field;\n\n  for (const [projectName, configuration] of Object.entries(\n    workspace.projects\n  )) {\n    for (const [targetName, target] of Object.entries(\n      configuration.targets ?? {}\n    )) {\n      const targetLabel = `${projectName}:${targetName}`;\n      projectTargetCompletion.push(\n        createCompletionItem(\n          targetLabel,\n          '',\n          node,\n          document,\n          completionItemKind\n        )\n      );\n\n      for (const configuration of Object.keys(target.configurations ?? {})) {\n        const configurationLabel = `${targetLabel}:${configuration}`;\n        projectTargetCompletion.push(\n          createCompletionItem(\n            configurationLabel,\n            '',\n            node,\n            document,\n            completionItemKind\n          )\n        );\n      }\n    }\n  }\n\n  return projectTargetCompletion;\n}\n","import { nxWorkspace } from '@nx-console/language-server/workspace';\nimport {\n  ASTNode,\n  CompletionItem,\n  CompletionItemKind,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport { createCompletionItem } from './create-completion-path-item';\n\nexport async function projectCompletion(\n  workingPath: string | undefined,\n  node: ASTNode,\n  document: TextDocument\n): Promise<CompletionItem[]> {\n  if (!workingPath) {\n    return [];\n  }\n\n  const { workspace } = await nxWorkspace(workingPath);\n\n  const projectCompletion: CompletionItem[] = [];\n\n  for (const projectName of Object.keys(workspace.projects)) {\n    projectCompletion.push(\n      createCompletionItem(\n        projectName,\n        '',\n        node,\n        document,\n        CompletionItemKind.Struct\n      ),\n      createCompletionItem(\n        `!${projectName}`,\n        '',\n        node,\n        document,\n        CompletionItemKind.Struct,\n        `Exclude \"${projectName}\" from this project's dependencies`\n      )\n    );\n  }\n\n  return projectCompletion;\n}\n","import { ASTNode, StringASTNode } from 'vscode-json-languageservice';\nimport { isPropertyNode, isStringNode } from './node-types';\n\nexport function isExecutorStringNode(node: ASTNode): node is StringASTNode {\n  return (\n    isStringNode(node) &&\n    isPropertyNode(node.parent) &&\n    node.parent.keyNode.value === 'executor'\n  );\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"nx/src/config/schema-utils\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"vscode-languageserver\");","import { ASTNode, Range, TextDocument } from 'vscode-json-languageservice';\n\nexport function createRange(document: TextDocument, node: ASTNode) {\n  const position = document.positionAt(node.offset);\n  const endPosition = document.positionAt(node.offset + node.length);\n  return Range.create(position, endPosition);\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@nx/devkit/src/executors/parse-target-string\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"vscode-languageserver-textdocument\");","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// https://github.com/microsoft/vscode/blob/89c30e1b86f941db095d9f52b128287e5039e004/extensions/json-language-features/server/src/languageModelCache.ts\n\nimport { JSONDocument } from 'vscode-json-languageservice';\nimport { TextDocument } from 'vscode-languageserver-textdocument';\nimport { getJsonLanguageService } from './json-language-service';\n\nexport interface LanguageModelCache<T> {\n  retrieve(\n    document: TextDocument,\n    stripSchema?: boolean\n  ): { jsonAst: T; document: TextDocument };\n  onDocumentRemoved(document: TextDocument): void;\n  dispose(): void;\n}\n\nconst parse = (document: TextDocument): JSONDocument | undefined =>\n  getJsonLanguageService()?.parseJSONDocument(document);\n\nlet languageModels: {\n  [uri: string]: {\n    version: number;\n    languageId: string;\n    cTime: number;\n    languageModel: JSONDocument;\n    document: TextDocument;\n  };\n} = {};\nconst maxEntries = 10;\nconst cleanupIntervalTimeInSec = 60;\nlet nModels = 0;\n\nlet cleanupInterval: NodeJS.Timer | undefined = undefined;\nif (cleanupIntervalTimeInSec > 0) {\n  cleanupInterval = setInterval(() => {\n    const cutoffTime = Date.now() - cleanupIntervalTimeInSec * 1000;\n    const uris = Object.keys(languageModels);\n    for (const uri of uris) {\n      const languageModelInfo = languageModels[uri];\n      if (languageModelInfo.cTime < cutoffTime) {\n        delete languageModels[uri];\n        nModels--;\n      }\n    }\n  }, cleanupIntervalTimeInSec * 1000);\n}\n\nexport function getLanguageModelCache(): LanguageModelCache<JSONDocument> {\n  return {\n    retrieve(\n      document: TextDocument,\n      stripSchema = true\n    ): {\n      jsonAst: JSONDocument;\n      document: TextDocument;\n    } {\n      const version = document.version;\n      const languageId = document.languageId;\n      const languageModelInfo = languageModels[document.uri];\n      if (\n        languageModelInfo &&\n        languageModelInfo.version === version &&\n        languageModelInfo.languageId === languageId\n      ) {\n        languageModelInfo.cTime = Date.now();\n        return {\n          jsonAst: languageModelInfo.languageModel,\n          document: languageModelInfo.document,\n        };\n      }\n\n      if (stripSchema) {\n        document = TextDocument.create(\n          document.uri,\n          document.languageId,\n          document.version,\n          document.getText().replace(/\"\\$schema\":\\s\".+\",/, '')\n        );\n      }\n\n      const languageModel = parse(document);\n\n      if (!languageModel) {\n        return {\n          jsonAst: {\n            root: undefined,\n            getNodeFromOffset() {\n              return undefined;\n            },\n          },\n          document,\n        };\n      }\n\n      languageModels[document.uri] = {\n        languageModel,\n        version,\n        languageId,\n        document,\n        cTime: Date.now(),\n      };\n      if (!languageModelInfo) {\n        nModels++;\n      }\n\n      if (nModels === maxEntries) {\n        let oldestTime = Number.MAX_VALUE;\n        let oldestUri = null;\n        for (const uri in languageModels) {\n          const languageModelInfo = languageModels[uri];\n          if (languageModelInfo.cTime < oldestTime) {\n            oldestUri = uri;\n            oldestTime = languageModelInfo.cTime;\n          }\n        }\n        if (oldestUri) {\n          delete languageModels[oldestUri];\n          nModels--;\n        }\n      }\n      return { jsonAst: languageModel, document };\n    },\n    onDocumentRemoved(document: TextDocument) {\n      const uri = document.uri;\n      if (languageModels[uri]) {\n        delete languageModels[uri];\n        nModels--;\n      }\n    },\n    dispose() {\n      if (typeof cleanupInterval !== 'undefined') {\n        clearInterval(cleanupInterval);\n        cleanupInterval = undefined;\n        languageModels = {};\n        nModels = 0;\n      }\n    },\n  };\n}\n","import { ASTNode } from 'vscode-json-languageservice';\nimport { isObjectNode, isPropertyNode } from './node-types';\n\n/**\n * Find the first property from the current node\n * @param node\n * @param property\n */\nexport function findProperty(\n  node: ASTNode | undefined,\n  property: string\n): ASTNode | undefined {\n  if (isPropertyNode(node) && node.valueNode) {\n    node = node.valueNode;\n  }\n\n  if (isObjectNode(node)) {\n    for (const child of node.properties) {\n      if (child.keyNode.value === property) {\n        return child;\n      }\n\n      if (isObjectNode(child.valueNode)) {\n        const found = findProperty(child.valueNode, property);\n        if (found) {\n          return found;\n        }\n      }\n    }\n  }\n\n  return undefined;\n}\n","import { parseTargetString } from '@nx/devkit/src/executors/parse-target-string';\nimport { fileExists, readFile } from '@nx-console/shared/file-system';\nimport {\n  findProperty,\n  getLanguageModelCache,\n  isStringNode,\n  lspLogger,\n} from '@nx-console/language-server/utils';\nimport { nxWorkspace } from '@nx-console/language-server/workspace';\nimport { join } from 'path';\nimport {\n  ASTNode,\n  JSONDocument,\n  Range,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport { URI } from 'vscode-uri';\nimport { createRange } from './create-range';\n\nconst tempDocumentCounter = new Map<string, number>();\n\nexport async function targetLink(\n  workingPath: string,\n  node: ASTNode\n): Promise<string | undefined> {\n  if (!isStringNode(node)) {\n    return;\n  }\n\n  const targetString = node.value;\n  let project, target, configuration;\n  try {\n    const parsedTargets = parseTargetString(targetString);\n    project = parsedTargets.project;\n    target = parsedTargets.target;\n    configuration = parsedTargets.configuration;\n  } catch (e) {\n    return;\n  }\n\n  const { workspace } = await nxWorkspace(workingPath, lspLogger);\n\n  const workspaceProject = workspace.projects[project];\n\n  if (!workspaceProject) {\n    lspLogger.log(`Could not find project ${project}`);\n    return;\n  }\n\n  const baseTargetPath = join(workingPath, workspaceProject.root);\n  const baseTargetProjectPath = join(baseTargetPath, 'project.json');\n\n  if (!(await fileExists(baseTargetProjectPath))) {\n    lspLogger.log(`Could not find target project: ${baseTargetProjectPath}`);\n    return;\n  }\n\n  const projectJson = await readFile(baseTargetProjectPath);\n\n  let versionNumber = 0;\n  if (tempDocumentCounter.has(baseTargetProjectPath)) {\n    versionNumber = tempDocumentCounter.get(baseTargetProjectPath) ?? 0;\n    tempDocumentCounter.set(baseTargetProjectPath, versionNumber + 1);\n  } else {\n    tempDocumentCounter.set(baseTargetProjectPath, versionNumber);\n  }\n\n  const { document, jsonAst } = getLanguageModelCache().retrieve(\n    TextDocument.create(\n      baseTargetProjectPath,\n      'json',\n      versionNumber,\n      projectJson\n    ),\n    false\n  );\n\n  const range = findTargetRange(document, jsonAst, target, configuration);\n\n  if (!range) {\n    return;\n  }\n\n  return URI.from({\n    scheme: 'file',\n    path: baseTargetProjectPath,\n    fragment: `${range.start.line + 1}`,\n  }).toString();\n}\n\nfunction findTargetRange(\n  document: TextDocument,\n  jsonAst: JSONDocument,\n  target: string,\n  configuration: string | undefined\n): Range | undefined {\n  if (!jsonAst.root) {\n    return;\n  }\n\n  const targetNode = findProperty(jsonAst.root, 'targets');\n\n  if (!targetNode) {\n    return;\n  }\n\n  // Find the target within the target object\n  const targetProperty = findProperty(targetNode, target);\n\n  if (!targetProperty) {\n    return;\n  }\n\n  if (configuration) {\n    const configurationNode = findProperty(targetProperty, configuration);\n\n    if (configurationNode) {\n      return createRange(document, configurationNode);\n    }\n  } else {\n    return createRange(document, targetProperty);\n  }\n}\n","import { crossFs } from './cache-json';\n\nexport async function readFile(filePath: string): Promise<string> {\n  try {\n    return crossFs.readFilePromise(filePath, 'utf8');\n  } catch {\n    return '';\n  }\n}\n","import {\n  ASTNode,\n  JSONDocument,\n  StringASTNode,\n} from 'vscode-json-languageservice';\nimport { TextDocument } from 'vscode-languageserver-textdocument';\nimport { Hover, HoverParams } from 'vscode-languageserver';\nimport {\n  getJsonLanguageService,\n  isExecutorStringNode,\n} from '@nx-console/language-server/utils';\n\nexport async function getHover(\n  hoverParams: HoverParams,\n  jsonAst: JSONDocument,\n  document: TextDocument\n): Promise<Hover | null | undefined> {\n  const hover = await getJsonLanguageService()?.doHover(\n    document,\n    hoverParams.position,\n    jsonAst\n  );\n\n  if (!hover) {\n    return;\n  }\n\n  const offset = document.offsetAt(hoverParams.position);\n  const node = jsonAst.getNodeFromOffset(offset);\n\n  if (!node) {\n    return hover;\n  }\n\n  if (isNxExecutorStringNode(node)) {\n    hover.contents = {\n      kind: 'markdown',\n      value: `[View executor documentation on nx.dev](${constructExecutorUrl(\n        node.value\n      )})`,\n    };\n  }\n\n  return hover;\n}\n\nfunction isNxExecutorStringNode(node: ASTNode): node is StringASTNode {\n  return (\n    isExecutorStringNode(node) &&\n    (RegExp(/@nx|@nrwl\\/\\w+:\\w+/).test(node.value) ||\n      RegExp(/nx:\\w+/).test(node.value))\n  );\n}\n\nfunction constructExecutorUrl(executor: string): string {\n  const [packageName, executorName] = executor\n    .replace(/@nx|@nrwl/, '')\n    .split(':');\n  return `https://nx.dev/packages/${packageName}/executors/${executorName}`;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"vscode-languageserver/node\");","import {\n  GeneratorContext,\n  GeneratorSchema,\n} from '@nx-console/shared/generate-ui-types';\nimport {\n  GeneratorCollectionInfo,\n  Option,\n  TaskExecutionSchema,\n} from '@nx-console/shared/schema';\nimport { NxVersion, NxWorkspace, TreeNode } from '@nx-console/shared/types';\nimport type {\n  ProjectConfiguration,\n  TargetConfiguration,\n} from 'nx/src/devkit-exports';\nimport { SemVer } from 'semver';\nimport { StartupMessageDefinition } from 'shared/nx-console-plugins';\nimport { NotificationType, RequestType } from 'vscode-languageserver/node';\n\nexport const NxChangeWorkspace: NotificationType<string> = new NotificationType(\n  'nx/changeWorkspace'\n);\n\nexport const NxWorkspaceRefreshNotification: NotificationType<void> =\n  new NotificationType('nx/refreshWorkspace');\n\nexport const NxReset: NotificationType<void> = new NotificationType('nx/reset');\n\nexport const NxWorkspaceRequest: RequestType<\n  { reset: boolean },\n  NxWorkspace,\n  unknown\n> = new RequestType('nx/workspace');\n\nexport const NxWorkspacePathRequest: RequestType<undefined, string, unknown> =\n  new RequestType('nx/workspacePath');\n\nexport type NxGeneratorsRequestOptions = {\n  includeHidden: boolean;\n  includeNgAdd: boolean;\n};\n\nexport const NxGeneratorsRequest: RequestType<\n  {\n    options?: NxGeneratorsRequestOptions;\n  },\n  GeneratorCollectionInfo[],\n  unknown\n> = new RequestType('nx/generators');\n\nexport type NxGeneratorOptionsRequestOptions = {\n  collection: string;\n  name: string;\n  path: string;\n};\n\nexport const NxGeneratorOptionsRequest: RequestType<\n  { options: NxGeneratorOptionsRequestOptions },\n  Option[],\n  unknown\n> = new RequestType('nx/generatorOptions');\n\nexport const NxProjectByPathRequest: RequestType<\n  { projectPath: string },\n  ProjectConfiguration | null,\n  unknown\n> = new RequestType('nx/projectByPath');\n\nexport const NxProjectsByPathsRequest: RequestType<\n  { paths: string[] },\n  { [path: string]: ProjectConfiguration | undefined },\n  unknown\n> = new RequestType('nx/projectsByPaths');\n\nexport const NxProjectByRootRequest: RequestType<\n  { projectRoot: string },\n  ProjectConfiguration | null,\n  unknown\n> = new RequestType('nx/projectByRoot');\n\nexport const NxGeneratorContextFromPathRequest: RequestType<\n  {\n    generator?: TaskExecutionSchema;\n    path: string;\n  },\n  | {\n      path?: string;\n      directory?: string;\n      project?: string;\n      projectName?: string;\n    }\n  | undefined,\n  unknown\n> = new RequestType('nx/generatorContextFromPath');\n\nexport const NxGeneratorContextV2Request: RequestType<\n  {\n    path: string | undefined;\n  },\n  GeneratorContext,\n  unknown\n> = new RequestType('nx/generatorContextV2');\n\nexport const NxVersionRequest: RequestType<undefined, NxVersion, unknown> =\n  new RequestType('nx/version');\n\nexport const NxProjectGraphOutputRequest: RequestType<\n  undefined,\n  {\n    directory: string;\n    relativePath: string;\n    fullPath: string;\n  },\n  unknown\n> = new RequestType('nx/projectGraphOutput');\n\nexport const NxCreateProjectGraphRequest: RequestType<\n  { showAffected: boolean },\n  string | undefined,\n  unknown\n> = new RequestType('nx/createProjectGraph');\n\nexport const NxProjectFolderTreeRequest: RequestType<\n  undefined,\n  {\n    serializedTreeMap: { name: string; node: TreeNode }[];\n    roots: TreeNode[];\n  },\n  unknown\n> = new RequestType('nx/projectFolderTree');\n\nexport const NxTransformedGeneratorSchemaRequest: RequestType<\n  GeneratorSchema,\n  GeneratorSchema,\n  unknown\n> = new RequestType('nx/transformedGeneratorSchema');\n\nexport const NxStartupMessageRequest: RequestType<\n  GeneratorSchema,\n  StartupMessageDefinition | undefined,\n  unknown\n> = new RequestType('nx/startupMessage');\n\nexport const NxHasAffectedProjectsRequest: RequestType<\n  undefined,\n  boolean,\n  unknown\n> = new RequestType('nx/hasAffectedProjects');\n\nexport const NxSourceMapFilesToProjectMapRequest: RequestType<\n  undefined,\n  Record<string, string>,\n  unknown\n> = new RequestType('nx/sourceMapFilesToProjectMap');\n\nexport const NxTargetsForConfigFileRequest: RequestType<\n  { projectName: string; configFilePath: string },\n  Record<string, TargetConfiguration>,\n  unknown\n> = new RequestType('nx/targetsForConfigFile');\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node:child_process\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"nx/src/utils/package-manager\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@parcel/watcher\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"nx/src/utils/ignore\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"minimatch\");","import { lspLogger } from '@nx-console/language-server/utils';\nimport * as watcher from '@parcel/watcher';\nimport { platform } from 'os';\nimport { getIgnoredGlobs } from 'nx/src/utils/ignore';\nimport { getNxVersion } from '@nx-console/language-server/workspace';\nimport { gte } from 'semver';\nimport type { WatchEvent } from 'nx/src/native';\nimport { debounce } from '@nx-console/shared/utils';\nimport { match as minimatch } from 'minimatch';\n\nconst NX_PLUGIN_PATTERNS_TO_WATCH = [\n  '**/cypress.config.{js,ts,mjs,cjs}',\n  '**/{detox.config,.detoxrc}.{json,js}',\n  '**/app.{json,config.js}',\n  '**/jest.config.{cjs,mjs,js,cts,mts,ts}',\n  '**/next.config.{js,cjs,mjs}',\n  '**/nuxt.config.{js,ts,mjs,mts,cjs,cts}',\n  '**/playwright.config.{js,ts,cjs,cts,mjs,mts}',\n  '**/remix.config.{js,cjs,mjs}',\n  '**/.storybook/main.{js,ts,mjs,mts,cjs,cts}',\n  '**/{vite,vitest}.config.{js,ts,mjs,mts,cjs,cts}',\n  '**/webpack.config.{js,ts,mjs,cjs}',\n  '**/jest.preset.js',\n  '**/tsconfig.*.json',\n  // nx-dotnet\n  '*{.csproj,fsproj,vbproj}',\n];\n\nexport async function languageServerWatcher(\n  workspacePath: string,\n  callback: () => unknown\n): Promise<() => void> {\n  const version = await getNxVersion(workspacePath);\n  const debouncedCallback = debounce(callback, 1000);\n\n  if (gte(version.full, '16.4.0')) {\n    const native = await import('nx/src/native');\n    const watcher = new native.Watcher(workspacePath);\n\n    watcher.watch((err: string | null, events: WatchEvent[]) => {\n      if (err) {\n        lspLogger.log('Error watching files: ' + err);\n      } else if (\n        events.some(\n          (e) =>\n            e.path.endsWith('project.json') ||\n            e.path.endsWith('package.json') ||\n            e.path.endsWith('nx.json') ||\n            e.path.endsWith('workspace.json') ||\n            e.path.endsWith('tsconfig.base.json') ||\n            NX_PLUGIN_PATTERNS_TO_WATCH.some((pattern) =>\n              minimatch([e.path], pattern, { dot: true })\n            )\n        )\n      ) {\n        lspLogger.log('Project configuration changed');\n        debouncedCallback();\n      }\n    });\n\n    return () => {\n      lspLogger.log('Unregistering file watcher');\n      watcher.stop();\n    };\n  } else {\n    const subscription = await watcher.subscribe(\n      workspacePath,\n      (err, events) => {\n        if (err) {\n          lspLogger.log('Error watching files: ' + err.toString());\n        } else if (\n          events.some(\n            (e) =>\n              e.path.endsWith('project.json') ||\n              e.path.endsWith('package.json') ||\n              e.path.endsWith('nx.json') ||\n              e.path.endsWith('workspace.json') ||\n              e.path.endsWith('tsconfig.base.json')\n          )\n        ) {\n          lspLogger.log('Project configuration changed');\n          debouncedCallback();\n        }\n      },\n      watcherOptions(workspacePath)\n    );\n\n    return () => {\n      lspLogger.log('Unregistering file watcher');\n      subscription.unsubscribe();\n    };\n  }\n}\n\nfunction watcherOptions(workspacePath: string): watcher.Options | undefined {\n  const options: watcher.Options = {\n    ignore: getIgnoredGlobs(workspacePath),\n  };\n\n  if (platform() === 'win32') {\n    options.backend = 'windows';\n  }\n\n  return options;\n}\n","import { readdirSync, statSync } from 'fs';\nimport * as path from 'path';\n\nexport function listFiles(dirName: string): string[] {\n  // TODO use .gitignore to skip files\n  if (dirName.indexOf('node_modules') > -1) return [];\n  if (dirName.indexOf('dist') > -1) return [];\n\n  const res = [dirName];\n  // the try-catch here is intentional. It's only used in auto-completion.\n  // If it doesn't work, we don't want the process to exit\n  try {\n    readdirSync(dirName).forEach((c) => {\n      const child = path.join(dirName, c);\n      try {\n        if (!statSync(child).isDirectory()) {\n          res.push(child);\n        } else if (statSync(child).isDirectory()) {\n          res.push(...listFiles(child));\n        }\n      } catch {\n        // noop\n      }\n    });\n  } catch {\n    // noop\n  }\n  return res;\n}\n","import {\n  CliOption,\n  ItemsWithEnum,\n  ItemTooltips,\n  LongFormXPrompt,\n  Option,\n  OptionItemLabelValue,\n  OptionPropertyDescription,\n  XPrompt,\n} from './schema';\nimport type { Schema } from 'nx/src/utils/params';\n\nexport interface GeneratorDefaults {\n  [name: string]: string;\n}\n\nexport async function normalizeSchema(\n  s: Schema,\n  projectDefaults?: GeneratorDefaults\n): Promise<Option[]> {\n  const options = schemaToOptions(s);\n  const requiredFields = new Set(s.required || []);\n\n  const nxOptions = options.map((option) => {\n    const xPrompt: XPrompt | undefined = option['x-prompt'];\n    const workspaceDefault =\n      projectDefaults?.[option.originalName ?? option.name];\n    const $default = option.$default;\n\n    const nxOption: Option = {\n      ...option,\n      isRequired: isFieldRequired(requiredFields, option, xPrompt, $default),\n      aliases: option.alias ? [option.alias] : [],\n      ...(workspaceDefault !== undefined && { default: workspaceDefault }),\n      ...($default && { $default }),\n      ...(option.enum && { items: option.enum.map((item) => item.toString()) }),\n      // Strongly suspect items does not belong in the Option schema.\n      //  Angular Option doesn't have the items property outside of x-prompt,\n      //  but items is used in @schematics/angular - guard\n      ...getItems(option),\n    };\n\n    if (xPrompt) {\n      nxOption.tooltip = isLongFormXPrompt(xPrompt) ? xPrompt.message : xPrompt;\n      nxOption.itemTooltips = getEnumTooltips(xPrompt);\n      if (isLongFormXPrompt(xPrompt) && !nxOption.items) {\n        const items = (xPrompt.items || []).map((item) =>\n          isOptionItemLabelValue(item)\n            ? typeof item.value === 'string'\n              ? item.value\n              : JSON.stringify(item.value)\n            : item\n        );\n        if (items.length > 0) {\n          nxOption.items = items;\n        }\n      }\n    }\n\n    return nxOption;\n  });\n\n  // since some folks are using Nx Console with older versions,\n  // we need to make sure their options are sorted like before\n  const optionComparator = nxOptions.some(\n    (option) => option['x-priority'] !== undefined\n  )\n    ? compareOptions\n    : legacyCompareOptions;\n\n  return nxOptions.sort(optionComparator);\n}\n\n/**\n * sorts options in the following order\n * - required\n * - x-priority: important\n * - everything else\n * - x-priority: internal\n * - deprecated\n * if two options are equal, they are sorted by whether they are positional args and name\n */\nfunction compareOptions(a: Option, b: Option): number {\n  function getPrio(opt: Option): number {\n    if (opt.isRequired) {\n      return 0;\n    }\n    if (opt['x-priority'] === 'important') {\n      return 1;\n    }\n    if (opt['x-deprecated']) {\n      return 4;\n    }\n    if (opt['x-priority'] === 'internal') {\n      return 3;\n    }\n    return 2;\n  }\n\n  const aPrio = getPrio(a);\n  const bPrio = getPrio(b);\n  if (aPrio === bPrio) {\n    if (typeof a.positional === 'number' && typeof b.positional === 'number') {\n      return a.positional - b.positional;\n    }\n    if (typeof a.positional === 'number') {\n      return -1;\n    } else if (typeof b.positional === 'number') {\n      return 1;\n    }\n    return a.name.localeCompare(b.name);\n  }\n  return aPrio - bPrio;\n}\n\nfunction legacyCompareOptions(a: Option, b: Option): number {\n  const IMPORTANT_FIELD_NAMES = [\n    'name',\n    'project',\n    'module',\n    'watch',\n    'style',\n    'directory',\n    'port',\n  ];\n  const IMPORTANT_FIELDS_SET = new Set(IMPORTANT_FIELD_NAMES);\n  if (typeof a.positional === 'number' && typeof b.positional === 'number') {\n    return a.positional - b.positional;\n  }\n\n  if (typeof a.positional === 'number') {\n    return -1;\n  } else if (typeof b.positional === 'number') {\n    return 1;\n  } else if (a.isRequired) {\n    if (b.isRequired) {\n      return a.name.localeCompare(b.name);\n    }\n    return -1;\n  } else if (b.isRequired) {\n    return 1;\n  } else if (IMPORTANT_FIELDS_SET.has(a.name)) {\n    if (IMPORTANT_FIELDS_SET.has(b.name)) {\n      return (\n        IMPORTANT_FIELD_NAMES.indexOf(a.name) -\n        IMPORTANT_FIELD_NAMES.indexOf(b.name)\n      );\n    }\n    return -1;\n  } else if (IMPORTANT_FIELDS_SET.has(b.name)) {\n    return 1;\n  } else {\n    return a.name.localeCompare(b.name);\n  }\n}\n\nfunction isFieldRequired(\n  requiredFields: Set<string>,\n  nxOption: CliOption,\n  xPrompt: XPrompt | undefined,\n  $default: any\n): boolean {\n  // checks schema.json requiredFields and xPrompt for required\n  return (\n    requiredFields.has(nxOption.name) ||\n    // makes xPrompt fields required so nx command can run with --no-interactive\n    // - except properties with a default (also falsey, empty, null)\n    // - except properties with a $default $source\n    // - except boolean properties (should also have default of `true`)\n    (!!xPrompt && !nxOption.default && !$default && nxOption.type !== 'boolean')\n  );\n}\n\nfunction getItems(option: CliOption): { items: string[] } | undefined {\n  return (\n    option.items && {\n      items:\n        (option.items as ItemsWithEnum).enum ||\n        ((option.items as string[]).length && option.items),\n    }\n  );\n}\n\nfunction isLongFormXPrompt(xPrompt: XPrompt): xPrompt is LongFormXPrompt {\n  return (xPrompt as Partial<LongFormXPrompt>).message !== undefined;\n}\n\nfunction getEnumTooltips(xPrompt: XPrompt): ItemTooltips {\n  const enumTooltips: ItemTooltips = {};\n  if (!!xPrompt && isLongFormXPrompt(xPrompt)) {\n    (xPrompt.items || []).forEach((item) => {\n      if (isOptionItemLabelValue(item) && !!item.label) {\n        enumTooltips[item.value] = item.label;\n      }\n    });\n  }\n  return enumTooltips;\n}\n\nfunction isOptionItemLabelValue(\n  item: string | OptionItemLabelValue\n): item is OptionItemLabelValue {\n  return (\n    (item as Partial<OptionItemLabelValue>).value !== undefined ||\n    (item as Partial<OptionItemLabelValue>).label !== undefined\n  );\n}\n\nfunction schemaToOptions(schema: Schema): CliOption[] {\n  return Object.keys(schema.properties || {}).reduce<CliOption[]>(\n    (cliOptions, option) => {\n      const currentProperty = schema.properties[option];\n      const $default = currentProperty.$default;\n      const $defaultIndex =\n        $default?.['$source'] === 'argv' ? $default['index'] : undefined;\n      const positional: number | undefined =\n        typeof $defaultIndex === 'number' ? $defaultIndex : undefined;\n\n      const visible = isPropertyVisible(option, currentProperty);\n      if (!visible) {\n        return cliOptions;\n      }\n      cliOptions.push({\n        name: option,\n        originalName: option,\n        positional,\n        ...currentProperty,\n      });\n      return cliOptions;\n    },\n    []\n  );\n}\n\nfunction isPropertyVisible(\n  option: string,\n  property: OptionPropertyDescription\n): boolean {\n  const ALWAYS_VISIBLE_OPTIONS = ['path'];\n\n  if (ALWAYS_VISIBLE_OPTIONS.includes(option)) {\n    return true;\n  }\n\n  if ('hidden' in property) {\n    return !(property as any)['hidden'];\n  }\n\n  return property.visible ?? true;\n}\n","import { NxGeneratorsRequestOptions } from '@nx-console/language-server/types';\nimport {\n  directoryExists,\n  fileExists,\n  listFiles,\n  readAndCacheJsonFile,\n} from '@nx-console/shared/file-system';\nimport {\n  CollectionInfo,\n  GeneratorCollectionInfo,\n  GeneratorType,\n} from '@nx-console/shared/schema';\nimport { normalizeSchema } from '@nx-console/shared/schema/normalize';\nimport { basename, join } from 'path';\nimport { getCollectionInfo, readCollections } from './read-collections';\n\nexport async function getGenerators(\n  workspacePath: string,\n  options: NxGeneratorsRequestOptions = {\n    includeHidden: false,\n    includeNgAdd: false,\n  }\n): Promise<GeneratorCollectionInfo[]> {\n  const basedir = workspacePath;\n  const collections = await readCollections(workspacePath, {\n    clearPackageJsonCache: false,\n    includeHidden: options.includeHidden,\n    includeNgAdd: options.includeNgAdd,\n  });\n  let generatorCollections = collections.filter(\n    (collection) => collection.type === 'generator'\n  );\n\n  generatorCollections = [\n    ...generatorCollections,\n    ...(await checkAndReadWorkspaceGenerators(basedir, 'schematics', options)),\n    ...(await checkAndReadWorkspaceGenerators(basedir, 'generators', options)),\n  ];\n  return generatorCollections.filter(\n    (collection): collection is GeneratorCollectionInfo =>\n      collection.type === 'generator'\n  );\n}\n\nasync function checkAndReadWorkspaceGenerators(\n  basedir: string,\n  workspaceGeneratorType: 'generators' | 'schematics',\n  options: NxGeneratorsRequestOptions\n) {\n  const workspaceGeneratorsPath = join('tools', workspaceGeneratorType);\n  if (await directoryExists(join(basedir, workspaceGeneratorsPath))) {\n    const collection = await readWorkspaceGeneratorsCollection(\n      basedir,\n      workspaceGeneratorsPath,\n      workspaceGeneratorType,\n      options\n    );\n    return collection;\n  }\n  return Promise.resolve([]);\n}\n\nasync function readWorkspaceGeneratorsCollection(\n  basedir: string,\n  workspaceGeneratorsPath: string,\n  workspaceGeneratorType: 'generators' | 'schematics',\n  options: NxGeneratorsRequestOptions\n): Promise<CollectionInfo[]> {\n  const collectionDir = join(basedir, workspaceGeneratorsPath);\n  const collectionName = `workspace-${\n    workspaceGeneratorType === 'generators' ? 'generator' : 'schematic'\n  }`;\n  const collectionPath = join(collectionDir, 'collection.json');\n  if (await fileExists(collectionPath)) {\n    const collection = await readAndCacheJsonFile(\n      `${collectionDir}/collection.json`\n    );\n\n    return getCollectionInfo(\n      basedir,\n      collectionName,\n      collectionPath,\n      {\n        path: collectionPath,\n        json: {},\n      },\n      collection.json,\n      options\n    );\n  } else {\n    return await Promise.all(\n      listFiles(collectionDir)\n        .filter((f) => basename(f) === 'schema.json')\n        .map(async (schemaJsonPath) => {\n          const schemaJson = await readAndCacheJsonFile(schemaJsonPath, '');\n          const name = schemaJson.json.id || schemaJson.json.$id;\n          const type: GeneratorType =\n            schemaJson.json['x-type'] ?? GeneratorType.Other;\n          return {\n            name: collectionName,\n            type: 'generator',\n            schemaPath: schemaJsonPath,\n            data: {\n              name,\n              collection: collectionName,\n              options: await normalizeSchema(schemaJson.json),\n              description: schemaJson.json.description ?? '',\n              type,\n            },\n          } as CollectionInfo;\n        })\n    );\n  }\n}\n","import { readAndCacheJsonFile } from '@nx-console/shared/file-system';\nimport { Option } from '@nx-console/shared/schema';\nimport { normalizeSchema } from '@nx-console/shared/schema/normalize';\nimport { nxWorkspace } from './workspace';\n\nexport async function getGeneratorOptions(\n  workspacePath: string,\n  collectionName: string,\n  generatorName: string,\n  generatorPath: string\n): Promise<Option[]> {\n  const generatorSchema = await readAndCacheJsonFile(generatorPath);\n  const workspaceDefaults = await readWorkspaceJsonDefaults(workspacePath);\n  const defaults =\n    workspaceDefaults &&\n    workspaceDefaults[collectionName] &&\n    workspaceDefaults[collectionName][generatorName];\n  return await normalizeSchema(generatorSchema.json, defaults);\n}\n\nasync function readWorkspaceJsonDefaults(workspacePath: string): Promise<any> {\n  const { workspace } = await nxWorkspace(workspacePath);\n\n  let defaults = workspace.generators;\n\n  if (!defaults) {\n    try {\n      /**\n       * This could potentially fail if we're in an Angular CLI project without schematics being part of angular.json\n       * Default the default to {} on the catch\n       */\n      defaults = workspace.generators || {};\n    } catch (e) {\n      defaults = {};\n    }\n  }\n\n  const collectionDefaults = Object.keys(defaults).reduce(\n    (collectionDefaultsMap: any, key) => {\n      if (key.includes(':')) {\n        const [collectionName, generatorName] = key.split(':');\n        if (!collectionDefaultsMap[collectionName]) {\n          collectionDefaultsMap[collectionName] = {};\n        }\n        collectionDefaultsMap[collectionName][generatorName] = defaults?.[key];\n      } else {\n        const collectionName = key;\n        if (!collectionDefaultsMap[collectionName]) {\n          collectionDefaultsMap[collectionName] = {};\n        }\n        Object.keys(defaults?.[collectionName] ?? {}).forEach(\n          (generatorName) => {\n            collectionDefaultsMap[collectionName][generatorName] =\n              defaults?.[collectionName][generatorName];\n          }\n        );\n      }\n      return collectionDefaultsMap;\n    },\n    {}\n  );\n  return collectionDefaults;\n}\n","import { GeneratorContext } from '@nx-console/shared/generate-ui-types';\nimport { existsSync, lstatSync } from 'fs';\nimport { normalize, parse } from 'path';\nimport { getProjectByPath } from './get-project-by-path';\nimport { nxWorkspace } from './workspace';\n\nexport async function getGeneratorContextV2(\n  path: string | undefined,\n  workspacePath: string\n): Promise<GeneratorContext> {\n  let projectName: string | undefined = undefined;\n  let directory: string | undefined = undefined;\n  let normalizedDirectory: string | undefined = undefined;\n\n  const { workspaceLayout, nxVersion } = await nxWorkspace(workspacePath);\n  if (path) {\n    const normalizedPath = normalize(path);\n    const project = await getProjectByPath(normalizedPath, workspacePath);\n\n    projectName = (project && project.name) || undefined;\n\n    directory = getDirectory(normalizedPath, workspacePath);\n\n    normalizedDirectory = getDirectoryWithoutAppsDirLibsDir(\n      normalizedPath,\n      workspaceLayout,\n      workspacePath\n    );\n  }\n\n  return {\n    project: projectName,\n    directory,\n    normalizedDirectory: normalizedDirectory,\n    nxVersion,\n  };\n}\n\nfunction getDirectory(path: string, workspacePath: string): string | undefined {\n  let dir: string | undefined = undefined;\n  if (existsSync(path)) {\n    if (lstatSync(path).isDirectory()) {\n      dir = path;\n    } else {\n      dir = parse(path).dir;\n    }\n  }\n\n  dir = dir?.replace(normalize(workspacePath), '');\n  return dir;\n}\n\nfunction getDirectoryWithoutAppsDirLibsDir(\n  path: string,\n  { appsDir, libsDir }: { appsDir?: string; libsDir?: string },\n  workspacePath: string\n) {\n  let dir = getDirectory(path, workspacePath);\n\n  if (!dir) {\n    return;\n  }\n\n  dir = dir.replace(/\\\\/g, '/').replace(/^\\//, '');\n\n  if (appsDir && dir.startsWith(appsDir)) {\n    dir = dir.replace(appsDir, '').replace(/^\\//, '');\n  }\n  if (libsDir && dir.startsWith(libsDir)) {\n    dir = dir.replace(libsDir, '').replace(/^\\//, '');\n  }\n\n  return dir;\n}\n","import { lspLogger } from '@nx-console/language-server/utils';\nimport { findNxPackagePath } from '@nx-console/shared/npm';\nimport { join, relative, normalize } from 'path';\nimport { getNxPackage } from './get-nx-workspace-package';\n\nexport async function getProjectGraphOutput(workspacePath: string) {\n  const cacheDir = await getCacheDir(workspacePath);\n\n  const directory = join(cacheDir, 'nx-console-project-graph');\n  const fullPath = `${directory}/project-graph.html`;\n  return {\n    directory,\n    relativePath: `./${normalize(relative(workspacePath, fullPath))}`,\n    fullPath,\n  };\n}\n\nasync function getCacheDir(workspacePath: string): Promise<string> {\n  const importPath = await findNxPackagePath(\n    workspacePath,\n    join('src', 'utils', 'cache-directory.js')\n  );\n\n  return ((await getNxPackage(importPath, lspLogger)) as any).cacheDir;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"child_process\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"util\");","import { NxWorkspace } from '@nx-console/shared/types';\nimport {\n  SchemaProcessor,\n  StartupMessageFactory,\n} from '../nx-console-plugin-types';\nimport { GeneratorSchema } from '@nx-console/shared/generate-ui-types';\n\nexport const nameAndDirectoryProcessor: SchemaProcessor = (\n  schema: GeneratorSchema,\n  workspace: NxWorkspace\n) => {\n  if (\n    !schema?.options?.find((option) => option.name === 'nameAndDirectoryFormat')\n  ) {\n    return schema;\n  }\n\n  const nadfDefault = schema.options.find(\n    (opt) => opt.name === 'nameAndDirectoryFormat'\n  )?.default;\n  return {\n    ...schema,\n    options: schema.options.map((option) => {\n      if (option.name === 'name') {\n        return {\n          ...option,\n          'x-priority': 'important',\n          'x-hint':\n            'You can provide a nested name instead of setting the directory option, e.g. my-dir/my-component',\n        };\n      }\n      if (option.name === 'directory') {\n        return {\n          ...option,\n          'x-priority': 'important',\n        };\n      }\n      if (option.name === 'project') {\n        return {\n          ...option,\n          'x-priority': undefined,\n          tooltip:\n            'When nameAndDirectoryFormat is set to as-provided, the project option will be ignored.',\n        };\n      }\n\n      return option;\n    }),\n    context: {\n      ...schema.context,\n      prefillValues: {\n        ...(schema.context?.prefillValues ?? {}),\n        nameAndDirectoryFormat: nadfDefault ? `${nadfDefault}` : 'as-provided',\n      },\n    },\n  };\n};\n\nexport const nameAndDirectoryStartupMessage: StartupMessageFactory = (\n  schema: GeneratorSchema,\n  workspace: NxWorkspace\n) => {\n  if (\n    !schema?.options?.find((option) => option.name === 'nameAndDirectoryFormat')\n  ) {\n    return undefined;\n  }\n\n  return {\n    message:\n      'Starting with Nx 17, Nx Console will generate artifacts with the exact name and directory provided. Check the output files to make sure that they were created in the correct location. You can revert to the old behavior by updating the nameAndDirectoryFormat option below.',\n    type: 'warning',\n  };\n};\n","import { NxConsolePluginsDefinition } from '../nx-console-plugin-types';\nimport { addProjectItemsToOptionProcessor } from './add-project-items-to-option-processor';\nimport { filterInternalAndDeprecatedProcessor } from './filter-internal-and-deprecated-processor';\nimport { gitCleanMessageFactory } from './git-clean-message-factory';\nimport {\n  nameAndDirectoryProcessor,\n  nameAndDirectoryStartupMessage,\n} from './name-and-directory.plugin';\nimport { prefillProjectAndDirProcessor } from './prefill-project-and-dir-processor';\nimport {\n  projectNameAndRootStartupMessage,\n  projectNameAndRootProcessor,\n} from './project-name-and-root-plugin';\n\nexport const internalPlugins: NxConsolePluginsDefinition = {\n  schemaProcessors: [\n    projectNameAndRootProcessor,\n    filterInternalAndDeprecatedProcessor,\n    prefillProjectAndDirProcessor,\n    nameAndDirectoryProcessor,\n    addProjectItemsToOptionProcessor,\n  ],\n  validators: [],\n  startupMessageFactories: [\n    gitCleanMessageFactory,\n    projectNameAndRootStartupMessage,\n    nameAndDirectoryStartupMessage,\n  ],\n};\n","import { GeneratorSchema } from '@nx-console/shared/generate-ui-types';\nimport {\n  SchemaProcessor,\n  StartupMessageFactory,\n} from '../nx-console-plugin-types';\nimport { NxWorkspace } from '@nx-console/shared/types';\nimport { Logger } from '@nx-console/shared/schema';\n\nexport const projectNameAndRootProcessor: SchemaProcessor = (\n  schema: GeneratorSchema,\n  workspace: NxWorkspace,\n  lspLogger: Logger\n) => {\n  if (\n    !schema?.options?.find(\n      (option) => option.name === 'projectNameAndRootFormat'\n    )\n  ) {\n    return schema;\n  }\n\n  // TODO: remove any after update\n  if (\n    (workspace.workspace.workspaceLayout as any)?.projectNameAndRootFormat ===\n    'derived'\n  ) {\n    return {\n      ...schema,\n      context: {\n        ...schema.context,\n        prefillValues: {\n          ...(schema.context?.prefillValues ?? {}),\n          projectNameAndRootFormat: 'derived',\n        },\n      },\n    };\n  }\n\n  const pnarfDefault = schema.options.find(\n    (opt) => opt.name === 'projectNameAndRootFormat'\n  )?.default;\n  return {\n    ...schema,\n    options: schema.options.map((option) => {\n      if (option.name === 'name') {\n        return {\n          ...option,\n          'x-priority': 'important',\n          'x-hint':\n            'You can provide a nested name instead of setting the directory option, e.g. my-dir/my-app',\n        };\n      }\n      if (option.name === 'directory') {\n        return {\n          ...option,\n          'x-priority': 'important',\n        };\n      }\n\n      return option;\n    }),\n    context: {\n      ...schema.context,\n      prefillValues: {\n        ...(schema.context?.prefillValues ?? {}),\n        projectNameAndRootFormat: pnarfDefault\n          ? `${pnarfDefault}`\n          : 'as-provided',\n      },\n    },\n  };\n};\n\nexport const projectNameAndRootStartupMessage: StartupMessageFactory = (\n  schema: GeneratorSchema,\n  workspace: NxWorkspace,\n  lspLogger: Logger\n) => {\n  if (\n    !schema?.options?.find(\n      (option) => option.name === 'projectNameAndRootFormat'\n    )\n  ) {\n    return undefined;\n  }\n  // TODO: remove any after update\n  if ((workspace.workspace.workspaceLayout as any)?.projectNameAndRootFormat) {\n    return undefined;\n  }\n  return {\n    message:\n      'Starting with Nx 16.7, Nx Console will generate projects with the exact name and directory provided. Check the output files to make sure that they were created in the correct location.',\n    type: 'warning',\n  };\n};\n","import { GeneratorSchema } from '@nx-console/shared/generate-ui-types';\n\nexport function filterInternalAndDeprecatedProcessor(\n  schema: GeneratorSchema\n): GeneratorSchema {\n  return {\n    ...schema,\n    options: (schema.options ?? []).filter((option) => {\n      if (option['x-priority'] === 'internal') {\n        return false;\n      }\n      if (option['x-deprecated']) {\n        return false;\n      }\n      return true;\n    }),\n  };\n}\n","import { GeneratorSchema } from '@nx-console/shared/generate-ui-types';\nimport { SchemaProcessor } from '../nx-console-plugin-types';\nimport { NxWorkspace } from '@nx-console/shared/types';\n\nexport const prefillProjectAndDirProcessor: SchemaProcessor = (\n  schema: GeneratorSchema,\n  workspace: NxWorkspace\n) => {\n  schema.context = schema.context ?? {};\n  schema.context.prefillValues = schema.context.prefillValues ?? {};\n\n  // before nx 17, path/directory options are inconsistent so we don't prefill project & directory simultaneously\n  // keep in mind that we normalize directory by appsDir & libsDir\n  if (workspace.nxVersion.major < 17) {\n    if (schema.context?.project) {\n      schema.context.prefillValues = {\n        ...(schema.context.prefillValues ?? {}),\n        project: schema.context.project,\n        projectName: schema.context.project,\n        directory: '',\n      };\n    } else if (schema.context?.normalizedDirectory) {\n      schema.context.prefillValues = {\n        ...(schema.context.prefillValues ?? {}),\n        directory: schema.context.normalizedDirectory,\n      };\n    }\n  }\n\n  // after nx 18 the format options will be removed.\n  // That means we should prefill cwd unless there's still a project / projectName option\n  if (workspace.nxVersion.major >= 18) {\n    if (\n      schema.options.find(\n        (o) => o.name === 'project' || o.name === 'projectName'\n      )\n    ) {\n      prefillProject();\n    } else {\n      prefillDirectoryAsCwd();\n    }\n  }\n\n  // after nx 17, we prefill the cwd\n  // project is also prefilled if there is no nameAndDirectoryFormat (which ignores project)\n  prefillDirectoryAsCwd();\n  if (\n    schema.options.find(\n      (o) => o.name === 'project' || o.name === 'projectName'\n    ) &&\n    schema.options.every((o) => o.name !== 'nameAndDirectoryFormat')\n  ) {\n    prefillProject();\n  }\n\n  return schema;\n\n  function prefillDirectoryAsCwd() {\n    if (schema.context?.directory && schema.context?.prefillValues) {\n      schema.context.prefillValues = {\n        ...schema.context.prefillValues,\n        cwd: schema.context?.directory,\n      };\n    } else if (schema.context?.project && schema.context?.prefillValues) {\n      const projectRoot =\n        workspace.workspace.projects[schema.context.project].root;\n      schema.context.prefillValues = {\n        ...schema.context.prefillValues,\n        cwd: projectRoot,\n      };\n    }\n  }\n\n  function prefillProject() {\n    if (schema.context?.project) {\n      schema.context.prefillValues = {\n        ...(schema.context.prefillValues ?? {}),\n        project: schema.context.project,\n        projectName: schema.context.project,\n      };\n    }\n  }\n};\n","import { GeneratorSchema } from '@nx-console/shared/generate-ui-types';\nimport { SchemaProcessor } from '../nx-console-plugin-types';\nimport { NxWorkspace } from '@nx-console/shared/types';\nimport { isProjectOption } from '@nx-console/shared/schema';\n\nexport const addProjectItemsToOptionProcessor: SchemaProcessor = (\n  schema: GeneratorSchema,\n  workspace: NxWorkspace\n) => {\n  return {\n    ...schema,\n    options: (schema.options ?? []).map((option) => {\n      if (isProjectOption(option)) {\n        const projects = Object.keys(workspace.workspace.projects);\n        option.items = projects.sort();\n      }\n      return option;\n    }),\n  };\n};\n","import { NxWorkspace } from '@nx-console/shared/types';\nimport { StartupMessageDefinition } from '../nx-console-plugin-types';\nimport { GeneratorSchema } from '@nx-console/shared/generate-ui-types';\nimport { promisify } from 'util';\nimport { exec } from 'child_process';\n\nexport async function gitCleanMessageFactory(\n  _: GeneratorSchema,\n  workspace: NxWorkspace\n): Promise<StartupMessageDefinition | undefined> {\n  const workspacePath = workspace.workspacePath;\n  try {\n    await promisify(exec)('git diff --quiet', {\n      cwd: workspacePath,\n      windowsHide: true,\n    });\n  } catch (e) {\n    return {\n      message:\n        'You have uncommitted changes in your workspace. We recommend that you commit any previous changes before running a generator, so that you can easily undo changes if necessary.',\n      type: 'warning',\n    };\n  }\n  return undefined;\n}\n","import { GeneratorSchema } from '@nx-console/shared/generate-ui-types';\nimport { existsSync } from 'fs';\nimport { nxWorkspace } from './workspace';\nimport { lspLogger } from '@nx-console/language-server/utils';\nimport {\n  NxConsolePluginsDefinition,\n  StartupMessageDefinition,\n  internalPlugins,\n} from 'shared/nx-console-plugins';\n\nexport async function getTransformedGeneratorSchema(\n  workspacePath: string,\n  schema: GeneratorSchema\n): Promise<GeneratorSchema> {\n  const plugins = await loadPlugins(workspacePath);\n  const workspace = await nxWorkspace(workspacePath);\n\n  let modifiedSchema = schema;\n  try {\n    plugins?.schemaProcessors?.forEach((processor) => {\n      modifiedSchema = processor(modifiedSchema, workspace, lspLogger);\n    });\n    return modifiedSchema;\n  } catch (e) {\n    lspLogger.log('error while applying schema processors' + e);\n    return modifiedSchema;\n  }\n}\n\nexport async function getStartupMessage(\n  workspacePath: string,\n  schema: GeneratorSchema\n): Promise<StartupMessageDefinition | undefined> {\n  const plugins = await loadPlugins(workspacePath);\n  const workspace = await nxWorkspace(workspacePath);\n\n  let startupMessageDefinition: StartupMessageDefinition | undefined =\n    undefined;\n  try {\n    for (const factory of plugins?.startupMessageFactories ?? []) {\n      const def = await factory(schema, workspace, lspLogger);\n      if (def) {\n        startupMessageDefinition = def;\n      }\n    }\n\n    return startupMessageDefinition;\n  } catch (e) {\n    lspLogger.log('error while getting startup message' + e);\n    return startupMessageDefinition;\n  }\n}\n\nasync function loadPlugins(\n  workspacePath: string\n): Promise<NxConsolePluginsDefinition> {\n  let workspacePlugins: NxConsolePluginsDefinition | undefined = undefined;\n  try {\n    const pluginFile = `${workspacePath}/.nx/console/plugins.mjs`;\n    if (!existsSync(pluginFile)) {\n      workspacePlugins = undefined;\n    }\n    workspacePlugins = await import(pluginFile).then(\n      (module) => module.default\n    );\n  } catch (_) {\n    workspacePlugins = undefined;\n  }\n\n  return {\n    schemaProcessors: [\n      ...(internalPlugins.schemaProcessors ?? []),\n      ...(workspacePlugins?.schemaProcessors ?? []),\n    ],\n    validators: [\n      ...(internalPlugins.validators ?? []),\n      ...(workspacePlugins?.validators ?? []),\n    ],\n    startupMessageFactories: [\n      ...(internalPlugins.startupMessageFactories ?? []),\n      ...(workspacePlugins?.startupMessageFactories ?? []),\n    ],\n  };\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.string.trim.js\");","import { TargetConfiguration } from 'nx/src/devkit-exports';\nimport { nxWorkspace } from './workspace';\nimport { normalize, relative } from 'path';\nimport { lspLogger } from '@nx-console/language-server/utils';\n\nlet _sourceMapFilesToProjectMap: Record<string, string> | undefined = undefined;\n\n/**\n * iterate over sourcemaps and return all files that were involved in creating a project along with the project name\n */\nexport async function getSourceMapFilesToProjectMap(\n  workingPath: string\n): Promise<Record<string, string>> {\n  if (_sourceMapFilesToProjectMap) {\n    return _sourceMapFilesToProjectMap;\n  }\n  const { workspace } = await nxWorkspace(workingPath);\n  const sourceMapFilesToProjectMap: Record<string, string> = {};\n\n  Object.entries(workspace.sourceMaps ?? {}).forEach(\n    ([projectRoot, sourceMap]) => {\n      Object.values(sourceMap).forEach(([file]) => {\n        if (!sourceMapFilesToProjectMap[file]) {\n          sourceMapFilesToProjectMap[file] = projectRoot;\n        }\n      });\n    }\n  );\n\n  _sourceMapFilesToProjectMap = sourceMapFilesToProjectMap;\n  return sourceMapFilesToProjectMap;\n}\n\nexport async function getTargetsForConfigFile(\n  projectName: string,\n  configFilePath: string,\n  workingPath: string\n): Promise<Record<string, TargetConfiguration> | undefined> {\n  const {\n    workspace: { sourceMaps, projects },\n  } = await nxWorkspace(workingPath);\n\n  if (normalize(configFilePath).includes(workingPath)) {\n    configFilePath = relative(workingPath, configFilePath);\n  }\n\n  const project = projects[projectName];\n\n  if (!project || !sourceMaps) {\n    return;\n  }\n\n  const sourceMap = sourceMaps[project.root];\n\n  const targets: Record<string, TargetConfiguration> = {};\n  Object.entries(sourceMap)\n    .filter(([key]) => key.startsWith('targets.'))\n    .forEach(([key, [file]]: [string, string[]]) => {\n      if (file === configFilePath) {\n        const targetName = key.split('.')[1];\n        const target = project.targets?.[targetName];\n        if (target) {\n          targets[targetName] = target;\n        }\n      }\n    });\n\n  return targets;\n}\n\nexport function resetSourceMapFilesToProjectCache() {\n  _sourceMapFilesToProjectMap = undefined;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node:path\");","import {\n  configureSchemaForProject,\n  configureSchemas,\n  getCompletionItems,\n  projectSchemaIsRegistered,\n} from '@nx-console/language-server/capabilities/code-completion';\nimport { getDefinition } from '@nx-console/language-server/capabilities/definition';\nimport { getDocumentLinks } from '@nx-console/language-server/capabilities/document-links';\nimport { getHover } from '@nx-console/language-server/capabilities/hover';\nimport {\n  NxChangeWorkspace,\n  NxCreateProjectGraphRequest,\n  NxGeneratorContextFromPathRequest,\n  NxGeneratorContextV2Request,\n  NxGeneratorOptionsRequest,\n  NxGeneratorOptionsRequestOptions,\n  NxGeneratorsRequest,\n  NxGeneratorsRequestOptions,\n  NxHasAffectedProjectsRequest,\n  NxProjectByPathRequest,\n  NxProjectByRootRequest,\n  NxProjectFolderTreeRequest,\n  NxProjectGraphOutputRequest,\n  NxProjectsByPathsRequest,\n  NxReset,\n  NxSourceMapFilesToProjectMapRequest,\n  NxStartupMessageRequest,\n  NxTargetsForConfigFileRequest,\n  NxTransformedGeneratorSchemaRequest,\n  NxVersionRequest,\n  NxWorkspacePathRequest,\n  NxWorkspaceRefreshNotification,\n  NxWorkspaceRequest,\n} from '@nx-console/language-server/types';\nimport {\n  getJsonLanguageService,\n  getLanguageModelCache,\n  lspLogger,\n  mergeArrays,\n  nxReset,\n  setLspLogger,\n} from '@nx-console/language-server/utils';\nimport { languageServerWatcher } from '@nx-console/language-server/watcher';\nimport {\n  createProjectGraph,\n  getGeneratorContextFromPath,\n  getGeneratorContextV2,\n  getGeneratorOptions,\n  getGenerators,\n  getNxVersion,\n  getProjectByPath,\n  getProjectByRoot,\n  getProjectFolderTree,\n  getProjectGraphOutput,\n  getProjectsByPaths,\n  getSourceMapFilesToProjectMap,\n  getStartupMessage,\n  getTargetsForConfigFile,\n  getTransformedGeneratorSchema,\n  hasAffectedProjects,\n  nxWorkspace,\n  resetNxVersionCache,\n  resetProjectPathCache,\n  resetSourceMapFilesToProjectCache,\n} from '@nx-console/language-server/workspace';\nimport { GeneratorSchema } from '@nx-console/shared/generate-ui-types';\nimport { TaskExecutionSchema } from '@nx-console/shared/schema';\nimport { NxWorkspace } from '@nx-console/shared/types';\nimport { formatError } from '@nx-console/shared/utils';\nimport { dirname, relative } from 'node:path';\nimport {\n  ClientCapabilities,\n  CompletionList,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport {\n  CreateFilesParams,\n  DeleteFilesParams,\n  FileOperationPatternKind,\n  InitializeResult,\n  ProposedFeatures,\n  ResponseError,\n  TextDocumentSyncKind,\n  TextDocuments,\n  createConnection,\n} from 'vscode-languageserver/node';\nimport { URI, Utils } from 'vscode-uri';\n\nprocess.on('unhandledRejection', (e: any) => {\n  connection.console.error(formatError(`Unhandled exception`, e));\n});\n\nprocess.on('uncaughtException', (e) => {\n  connection.console.error(formatError('Unhandled exception', e));\n});\n\nlet WORKING_PATH: string | undefined = undefined;\nlet CLIENT_CAPABILITIES: ClientCapabilities | undefined = undefined;\nlet unregisterFileWatcher: () => void = () => {\n  //noop\n};\n\nlet reconfigureAttempts = 0;\n\nconst workspaceContext = {\n  resolveRelativePath: (relativePath: string, resource: string) => {\n    const base = resource.substring(0, resource.lastIndexOf('/') + 1);\n    return Utils.resolvePath(URI.parse(base), relativePath).toString();\n  },\n};\n\nconst connection = createConnection(ProposedFeatures.all);\n\n// Create a text document manager.\nconst documents = new TextDocuments(TextDocument);\n\n// Make the text document manager listen on the connection\n// for open, change and close text document events\ndocuments.listen(connection);\n\nconnection.onInitialize(async (params) => {\n  setLspLogger(connection);\n\n  const { workspacePath } = params.initializationOptions ?? {};\n  try {\n    WORKING_PATH =\n      workspacePath ||\n      params.workspaceFolders?.[0]?.uri ||\n      params.rootPath ||\n      URI.parse(params.rootUri ?? '').fsPath;\n\n    if (!WORKING_PATH) {\n      throw 'Unable to determine workspace path';\n    }\n\n    CLIENT_CAPABILITIES = params.capabilities;\n\n    configureSchemas(WORKING_PATH, workspaceContext, CLIENT_CAPABILITIES);\n    unregisterFileWatcher = await languageServerWatcher(\n      WORKING_PATH,\n      async () => {\n        if (!WORKING_PATH) {\n          return;\n        }\n        await reconfigureAndSendNotificationWithBackoff(WORKING_PATH);\n      }\n    );\n  } catch (e) {\n    lspLogger.log('Unable to get Nx info: ' + e.toString());\n  }\n\n  const result: InitializeResult = {\n    capabilities: {\n      textDocumentSync: TextDocumentSyncKind.Incremental,\n      completionProvider: {\n        resolveProvider: false,\n        triggerCharacters: ['\"', ':'],\n      },\n      hoverProvider: true,\n      definitionProvider: true,\n      documentLinkProvider: {\n        resolveProvider: false,\n        workDoneProgress: false,\n      },\n      workspace: {\n        fileOperations: {\n          didCreate: {\n            filters: [\n              {\n                pattern: {\n                  glob: '**/project.json',\n                  matches: FileOperationPatternKind.file,\n                },\n              },\n            ],\n          },\n          didDelete: {\n            filters: [\n              {\n                pattern: {\n                  glob: '**/project.json',\n                  matches: FileOperationPatternKind.file,\n                },\n              },\n            ],\n          },\n        },\n      },\n    },\n  };\n\n  return result;\n});\n\nconnection.onCompletion(async (completionParams) => {\n  if (!WORKING_PATH) {\n    return new ResponseError(1000, 'Unable to get Nx info: no workspace path');\n  }\n\n  const changedDocument = documents.get(completionParams.textDocument.uri);\n  if (!changedDocument) {\n    return null;\n  }\n\n  const { jsonAst, document } = getJsonDocument(changedDocument);\n\n  // get the project name from either the json AST (fast) or via the file path (slow)\n  // if the project is not yet registered with the json language service, register it\n  const uri = URI.parse(changedDocument.uri).fsPath;\n  if (uri.endsWith('project.json')) {\n    let relativeRootPath = relative(WORKING_PATH, dirname(uri));\n    // the root project will have a path of '' while nx thinks of the path as '.'\n    if (relativeRootPath === '') {\n      relativeRootPath = '.';\n    }\n\n    if (relativeRootPath && !projectSchemaIsRegistered(relativeRootPath)) {\n      await configureSchemaForProject(\n        relativeRootPath,\n        WORKING_PATH,\n        workspaceContext,\n        CLIENT_CAPABILITIES\n      );\n    }\n  }\n  const completionResults =\n    (await getJsonLanguageService()?.doComplete(\n      document,\n      completionParams.position,\n      jsonAst\n    )) ?? CompletionList.create([]);\n\n  const schemas = await getJsonLanguageService()?.getMatchingSchemas(\n    document,\n    jsonAst\n  );\n\n  if (!schemas) {\n    return completionResults;\n  }\n\n  const { nxVersion } = await nxWorkspace(WORKING_PATH, lspLogger);\n\n  const pathItems = await getCompletionItems(\n    WORKING_PATH,\n    nxVersion,\n    jsonAst,\n    document,\n    schemas,\n    completionParams.position\n  );\n  mergeArrays(completionResults.items, pathItems);\n\n  return completionResults;\n});\n\nconnection.onHover(async (hoverParams) => {\n  const hoverDocument = documents.get(hoverParams.textDocument.uri);\n\n  if (!hoverDocument) {\n    return null;\n  }\n\n  const { jsonAst, document } = getJsonDocument(hoverDocument);\n  return await getHover(hoverParams, jsonAst, document);\n});\n\nconnection.onDefinition((definitionParams) => {\n  const definitionDocument = documents.get(definitionParams.textDocument.uri);\n\n  if (!definitionDocument || !WORKING_PATH) {\n    return null;\n  }\n\n  const { jsonAst, document } = getJsonDocument(definitionDocument);\n\n  return getDefinition(WORKING_PATH, definitionParams, jsonAst, document);\n});\n\nconnection.onDocumentLinks(async (params) => {\n  const linkDocument = documents.get(params.textDocument.uri);\n\n  if (!linkDocument) {\n    return null;\n  }\n\n  const { jsonAst, document } = getJsonDocument(linkDocument);\n\n  const schemas = await getJsonLanguageService()?.getMatchingSchemas(\n    document,\n    jsonAst\n  );\n\n  if (!schemas) {\n    return;\n  }\n\n  return getDocumentLinks(WORKING_PATH, jsonAst, document, schemas);\n});\n\nconst jsonDocumentMapper = getLanguageModelCache();\n\ndocuments.onDidClose((e) => {\n  jsonDocumentMapper.onDocumentRemoved(e.document);\n});\n\ndocuments.onDidOpen(async (e) => {\n  if (!e.document.uri.endsWith('project.json')) {\n    return;\n  }\n  const project = await getProjectByPath(\n    URI.parse(e.document.uri).fsPath,\n    WORKING_PATH!\n  );\n\n  if (!project || !project.name) {\n    return;\n  }\n\n  if (projectSchemaIsRegistered(project.name)) {\n    return;\n  }\n\n  configureSchemaForProject(\n    project.name,\n    WORKING_PATH,\n    workspaceContext,\n    CLIENT_CAPABILITIES\n  );\n});\n\nconnection.onShutdown(() => {\n  unregisterFileWatcher();\n  jsonDocumentMapper.dispose();\n});\n\nconnection.onNotification(NxReset, async () => {\n  if (!WORKING_PATH) {\n    return new ResponseError(1000, 'Unable to get Nx info: no workspace path');\n  }\n\n  await nxReset(WORKING_PATH, lspLogger);\n  await reconfigureAndSendNotificationWithBackoff(WORKING_PATH);\n});\n\nconnection.onRequest(NxWorkspaceRequest, async ({ reset }) => {\n  if (!WORKING_PATH) {\n    return new ResponseError(1000, 'Unable to get Nx info: no workspace path');\n  }\n\n  return nxWorkspace(WORKING_PATH, lspLogger, reset);\n});\n\nconnection.onRequest(NxWorkspacePathRequest, () => {\n  return WORKING_PATH;\n});\n\nconnection.onRequest(\n  NxGeneratorsRequest,\n  async (args: { options?: NxGeneratorsRequestOptions }) => {\n    if (!WORKING_PATH) {\n      return new ResponseError(\n        1000,\n        'Unable to get Nx info: no workspace path'\n      );\n    }\n\n    return getGenerators(WORKING_PATH, args.options);\n  }\n);\n\nconnection.onRequest(\n  NxGeneratorOptionsRequest,\n  async (args: { options: NxGeneratorOptionsRequestOptions }) => {\n    if (!WORKING_PATH) {\n      return new ResponseError(\n        1000,\n        'Unable to get Nx info: no workspace path'\n      );\n    }\n\n    return getGeneratorOptions(\n      WORKING_PATH,\n      args.options.collection,\n      args.options.name,\n      args.options.path\n    );\n  }\n);\n\nconnection.onRequest(\n  NxProjectByPathRequest,\n  async (args: { projectPath: string }) => {\n    if (!WORKING_PATH) {\n      return new ResponseError(\n        1000,\n        'Unable to get Nx info: no workspace path'\n      );\n    }\n    return getProjectByPath(args.projectPath, WORKING_PATH);\n  }\n);\n\nconnection.onRequest(\n  NxProjectsByPathsRequest,\n  async (args: { paths: string[] }) => {\n    if (!WORKING_PATH) {\n      return new ResponseError(\n        1000,\n        'Unable to get Nx info: no workspace path'\n      );\n    }\n    return getProjectsByPaths(args.paths, WORKING_PATH);\n  }\n);\n\nconnection.onRequest(\n  NxProjectByRootRequest,\n  async (args: { projectRoot: string }) => {\n    if (!WORKING_PATH) {\n      return new ResponseError(\n        1000,\n        'Unable to get Nx info: no workspace path'\n      );\n    }\n    return getProjectByRoot(args.projectRoot, WORKING_PATH);\n  }\n);\n\n// TODO: REMOVE ONCE OLD GENERATE UI IS GONE\nconnection.onRequest(\n  NxGeneratorContextFromPathRequest,\n  async (args: { generator?: TaskExecutionSchema; path: string }) => {\n    if (!WORKING_PATH) {\n      return new ResponseError(\n        1000,\n        'Unable to get Nx info: no workspace path'\n      );\n    }\n    return getGeneratorContextFromPath(args.generator, args.path, WORKING_PATH);\n  }\n);\n\nconnection.onRequest(\n  NxGeneratorContextV2Request,\n  async (args: { path: string | undefined }) => {\n    if (!WORKING_PATH) {\n      return new ResponseError(\n        1000,\n        'Unable to get Nx info: no workspace path'\n      );\n    }\n    return getGeneratorContextV2(args.path, WORKING_PATH);\n  }\n);\n\nconnection.onRequest(NxVersionRequest, async () => {\n  if (!WORKING_PATH) {\n    return new ResponseError(1000, 'Unable to get Nx info: no workspace path');\n  }\n  return getNxVersion(WORKING_PATH);\n});\n\nconnection.onRequest(NxProjectGraphOutputRequest, async () => {\n  if (!WORKING_PATH) {\n    return new ResponseError(1000, 'Unable to get Nx info: no workspace path');\n  }\n  return getProjectGraphOutput(WORKING_PATH);\n});\n\nconnection.onRequest(NxCreateProjectGraphRequest, async ({ showAffected }) => {\n  if (!WORKING_PATH) {\n    return new ResponseError(1000, 'Unable to get Nx info: no workspace path');\n  }\n  try {\n    await createProjectGraph(WORKING_PATH, showAffected, lspLogger);\n  } catch (e) {\n    lspLogger.log('Error creating project graph: ' + e.toString());\n    return e;\n  }\n});\n\nconnection.onRequest(NxProjectFolderTreeRequest, async () => {\n  if (!WORKING_PATH) {\n    return new ResponseError(1000, 'Unable to get Nx info: no workspace path');\n  }\n  return await getProjectFolderTree(WORKING_PATH);\n});\n\nconnection.onRequest(\n  NxTransformedGeneratorSchemaRequest,\n  async (schema: GeneratorSchema) => {\n    if (!WORKING_PATH) {\n      return new ResponseError(\n        1000,\n        'Unable to get Nx info: no workspace path'\n      );\n    }\n    return getTransformedGeneratorSchema(WORKING_PATH, schema);\n  }\n);\n\nconnection.onRequest(\n  NxStartupMessageRequest,\n  async (schema: GeneratorSchema) => {\n    if (!WORKING_PATH) {\n      return new ResponseError(\n        1000,\n        'Unable to get Nx info: no workspace path'\n      );\n    }\n    return getStartupMessage(WORKING_PATH, schema);\n  }\n);\n\nconnection.onRequest(NxHasAffectedProjectsRequest, async () => {\n  if (!WORKING_PATH) {\n    return new ResponseError(1000, 'Unable to get Nx info: no workspace path');\n  }\n  return hasAffectedProjects(WORKING_PATH, lspLogger);\n});\n\nconnection.onRequest(NxSourceMapFilesToProjectMapRequest, async () => {\n  if (!WORKING_PATH) {\n    return new ResponseError(1000, 'Unable to get Nx info: no workspace path');\n  }\n  return getSourceMapFilesToProjectMap(WORKING_PATH);\n});\n\nconnection.onRequest(\n  NxTargetsForConfigFileRequest,\n  async (args: { projectName: string; configFilePath: string }) => {\n    if (!WORKING_PATH) {\n      return new ResponseError(\n        1000,\n        'Unable to get Nx info: no workspace path'\n      );\n    }\n    return getTargetsForConfigFile(\n      args.projectName,\n      args.configFilePath,\n      WORKING_PATH\n    );\n  }\n);\n\nconnection.onNotification(NxWorkspaceRefreshNotification, async () => {\n  if (!WORKING_PATH) {\n    return new ResponseError(1001, 'Unable to get Nx info: no workspace path');\n  }\n\n  await reconfigureAndSendNotificationWithBackoff(WORKING_PATH);\n});\n\nconnection.onNotification(\n  'workspace/didCreateFiles',\n  async (createdFiles: CreateFilesParams) => {\n    if (!createdFiles.files.some((f) => f.uri.endsWith('project.json'))) {\n      return;\n    }\n\n    if (!WORKING_PATH) {\n      return new ResponseError(\n        1001,\n        'Unable to get Nx info: no workspace path'\n      );\n    }\n\n    await reconfigure(WORKING_PATH);\n  }\n);\n\nconnection.onNotification(\n  'workspace/didDeleteFiles',\n  async (deletedFiles: DeleteFilesParams) => {\n    if (!deletedFiles.files.some((f) => f.uri.endsWith('project.json'))) {\n      return;\n    }\n\n    if (!WORKING_PATH) {\n      return new ResponseError(\n        1001,\n        'Unable to get Nx info: no workspace path'\n      );\n    }\n\n    await reconfigure(WORKING_PATH);\n  }\n);\n\nconnection.onNotification(NxChangeWorkspace, async (workspacePath) => {\n  WORKING_PATH = workspacePath;\n  await reconfigure(WORKING_PATH);\n});\n\nasync function reconfigureAndSendNotificationWithBackoff(workingPath: string) {\n  const workspace = await reconfigure(workingPath);\n  await connection.sendNotification(NxWorkspaceRefreshNotification.method);\n\n  if (!workspace?.error) {\n    reconfigureAttempts = 0;\n    return;\n  }\n\n  if (reconfigureAttempts < 5) {\n    reconfigureAttempts++;\n    lspLogger.log(\n      `reconfiguration failed, trying again in ${\n        reconfigureAttempts * reconfigureAttempts\n      } seconds`\n    );\n    new Promise((resolve) =>\n      setTimeout(resolve, 1000 * reconfigureAttempts * reconfigureAttempts)\n    ).then(() => reconfigureAndSendNotificationWithBackoff(workingPath));\n  } else {\n    lspLogger.log(\n      `reconfiguration failed after ${reconfigureAttempts} attempts`\n    );\n    reconfigureAttempts = 0;\n  }\n}\n\nasync function reconfigure(\n  workingPath: string\n): Promise<NxWorkspace | undefined> {\n  resetNxVersionCache();\n  resetProjectPathCache();\n  resetSourceMapFilesToProjectCache();\n  const workspace = await nxWorkspace(workingPath, lspLogger, true);\n  await configureSchemas(workingPath, workspaceContext, CLIENT_CAPABILITIES);\n\n  return workspace;\n}\n\nfunction getJsonDocument(document: TextDocument) {\n  return jsonDocumentMapper.retrieve(document);\n}\n\nconnection.listen();\n","/**\n * Combines the second array with the first array, without having to loop or change the reference of the first array.\n * @param arr1\n * @param arr2\n */\nexport function mergeArrays(arr1: Array<unknown>, arr2: Array<unknown>) {\n  Array.prototype.push.apply(arr1, arr2);\n}\n","import { isExecutorStringNode } from '@nx-console/language-server/utils';\nimport { getExecutors } from '@nx-console/language-server/workspace';\nimport { resolveImplementation } from 'nx/src/config/schema-utils';\nimport { dirname } from 'path';\nimport { JSONDocument } from 'vscode-json-languageservice';\nimport { DefinitionParams, LocationLink } from 'vscode-languageserver';\nimport { TextDocument } from 'vscode-languageserver-textdocument';\nimport { URI } from 'vscode-uri';\n\nexport async function getDefinition(\n  workingPath: string,\n  definitionParams: DefinitionParams,\n  jsonAst: JSONDocument,\n  document: TextDocument\n): Promise<LocationLink[] | undefined> {\n  const offset = document.offsetAt(definitionParams.position);\n  const node = jsonAst.getNodeFromOffset(offset);\n\n  if (!node || !isExecutorStringNode(node)) {\n    return undefined;\n  }\n\n  const executors = await getExecutors(workingPath);\n\n  const executor = executors.find((e) => e.name === node.value);\n\n  if (!executor) {\n    return undefined;\n  }\n\n  const executorFile = resolveImplementation(\n    executor.implementationPath,\n    dirname(executor.configPath)\n  );\n\n  return [\n    LocationLink.create(\n      URI.file(executorFile).toString(),\n      // Link to start of file because we cannot find the exact location without parsing the file\n      {\n        start: {\n          line: 0,\n          character: 0,\n        },\n        end: {\n          line: 0,\n          character: 0,\n        },\n      },\n      {\n        start: {\n          line: 0,\n          character: 0,\n        },\n        end: {\n          line: 0,\n          character: 0,\n        },\n      },\n      {\n        // So that the underline is\n        // \"executor\": \"nx:build\"\n        //              ^^^^^^^^\n        start: document.positionAt(node.offset + 1),\n        end: document.positionAt(node.offset + node.length - 1),\n      }\n    ),\n  ];\n}\n","import { fileExists } from '@nx-console/shared/file-system';\nimport {\n  CompletionType,\n  hasCompletionType,\n  X_COMPLETION_TYPE,\n} from '@nx-console/shared/json-schema';\nimport {\n  findProjectRoot,\n  getDefaultCompletionType,\n  hasDefaultCompletionType,\n  isStringNode,\n} from '@nx-console/language-server/utils';\nimport { join } from 'path';\nimport {\n  DocumentLink,\n  JSONDocument,\n  MatchingSchema,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport { createRange } from './create-range';\nimport { targetLink } from './target-link';\n\nexport async function getDocumentLinks(\n  workingPath: string | undefined,\n  jsonAst: JSONDocument,\n  document: TextDocument,\n  schemas: MatchingSchema[]\n): Promise<DocumentLink[]> {\n  if (!workingPath) {\n    return [];\n  }\n\n  const links: DocumentLink[] = [];\n\n  if (!jsonAst.root) {\n    return [];\n  }\n\n  const projectRoot = findProjectRoot(jsonAst.root);\n  const projectRootPath = join(workingPath, projectRoot);\n\n  for (const { schema, node } of schemas) {\n    let linkType: CompletionType | undefined;\n    if (hasCompletionType(schema)) {\n      linkType = schema[X_COMPLETION_TYPE];\n    } else if (hasDefaultCompletionType(node)) {\n      linkType = getDefaultCompletionType(node)?.completionType;\n    }\n\n    if (!linkType) {\n      continue;\n    }\n\n    if (linkType === 'directory') {\n      continue;\n    }\n\n    const range = createRange(document, node);\n\n    switch (linkType) {\n      case 'file': {\n        if (!isStringNode(node)) {\n          continue;\n        }\n\n        const fullPath = join(workingPath, node.value);\n        if (!(await fileExists(fullPath))) {\n          continue;\n        }\n\n        if (node.value === projectRoot) {\n          links.push({\n            range,\n            target: projectRootPath,\n          });\n        } else {\n          links.push(DocumentLink.create(range, fullPath));\n        }\n        break;\n      }\n      case 'projectTarget': {\n        const link = await targetLink(workingPath, node);\n        if (link) {\n          links.push(DocumentLink.create(range, link));\n        }\n        break;\n      }\n      default:\n    }\n  }\n\n  return links;\n}\n","import { Logger } from '@nx-console/shared/schema';\nimport { exec } from 'node:child_process';\nimport {\n  detectPackageManager,\n  getPackageManagerCommand,\n} from 'nx/src/utils/package-manager';\n\nexport async function nxReset(workspacePath: string, logger: Logger) {\n  logger.log('Resetting workspace with `nx reset`');\n  const packageManagerCommands = getPackageManagerCommand(\n    detectPackageManager(workspacePath)\n  );\n  return new Promise<void>((res, rej) => {\n    exec(\n      `${packageManagerCommands.exec} nx reset`,\n      {\n        cwd: workspacePath,\n      },\n      (err) => {\n        if (err) {\n          rej(err);\n        } else {\n          res();\n        }\n      }\n    );\n  }).then(() => {\n    return new Promise<void>((res, rej) => {\n      logger.log('Starting Nx daemon');\n      exec(\n        `${packageManagerCommands.exec} nx daemon --start`,\n        {\n          cwd: workspacePath,\n        },\n        (err) => {\n          if (err) {\n            rej(err);\n          } else {\n            res();\n          }\n        }\n      );\n    });\n  });\n}\n","import {\n  TaskExecutionSchema,\n  isProjectOption,\n} from '@nx-console/shared/schema';\nimport { getProjectByPath } from './get-project-by-path';\nimport { nxWorkspace } from './workspace';\n\nexport async function getGeneratorContextFromPath(\n  generator: TaskExecutionSchema | undefined,\n  path: string,\n  workspacePath: string\n): Promise<\n  | {\n      path?: string;\n      directory?: string;\n      project?: string;\n      projectName?: string;\n    }\n  | undefined\n> {\n  if (!path) {\n    return;\n  }\n  const project = await getProjectByPath(path, workspacePath);\n  const projectName = (project && project.name) || undefined;\n\n  let modifiedPath = path\n    .replace(workspacePath, '')\n    .replace(/\\\\/g, '/')\n    .replace(/^\\//, '');\n\n  const { workspaceLayout } = await nxWorkspace(workspacePath);\n  const appsDir = workspaceLayout.appsDir;\n  const libsDir = workspaceLayout.libsDir;\n  if (\n    appsDir &&\n    (generator?.name === 'application' ||\n      generator?.name === 'app' ||\n      modifiedPath.startsWith(appsDir))\n  ) {\n    modifiedPath = modifiedPath.replace(appsDir, '').replace(/^\\//, '');\n  }\n  if (\n    libsDir &&\n    (generator?.name === 'library' ||\n      generator?.name === 'lib' ||\n      modifiedPath.startsWith(libsDir))\n  ) {\n    modifiedPath = modifiedPath.replace(libsDir, '').replace(/^\\//, '');\n  }\n\n  return {\n    project: projectName,\n    projectName,\n    path: modifiedPath,\n    ...(!(projectName && generator?.options?.some(isProjectOption)) && {\n      directory: modifiedPath,\n    }),\n  };\n}\n","import { Logger } from '@nx-console/shared/schema';\nimport { getNxExecutionCommand } from '@nx-console/shared/utils';\n\nimport { execSync } from 'child_process';\nimport { getProjectGraphOutput } from './get-project-graph-output';\nimport { nxWorkspace } from './workspace';\n\nexport async function createProjectGraph(\n  workspacePath: string,\n  showAffected: boolean,\n  logger: Logger = {\n    log(message) {\n      console.log(message);\n    },\n  }\n): Promise<string | undefined> {\n  const { isEncapsulatedNx } = await nxWorkspace(workspacePath);\n  const projectGraphOutput = await getProjectGraphOutput(workspacePath);\n\n  return new Promise<string | undefined>((res, rej) => {\n    const command = getNxExecutionCommand({\n      cwd: workspacePath,\n      displayCommand:\n        `nx graph ${showAffected ? '--affected' : ''} --file ` +\n        projectGraphOutput.relativePath,\n      encapsulatedNx: isEncapsulatedNx,\n    });\n\n    logger.log(`Generating graph with command: \\`${command}\\``);\n    try {\n      execSync(command, {\n        cwd: workspacePath,\n        windowsHide: true,\n        // Since this is going to be used within nxls, we need to make sure that stdio is set to ignore\n        // The lsp is set up to write to the host on stdio, so if we pollute the stdio with data that is not\n        // standard lsp, the connection will close because of malformed data.\n        stdio: 'ignore',\n      });\n\n      res(undefined);\n    } catch (e) {\n      const errorMessage = `${e.output[1] || e}`;\n      rej('Unable to create project graph: ' + errorMessage);\n    }\n  });\n}\n","import { NxProjectConfiguration, TreeNode } from '@nx-console/shared/types';\nimport { parse } from 'path';\nimport { nxWorkspace } from './workspace';\n\n/*\n * Construct a tree (all nodes are saved in a map) from the project definitions by doing the following:\n * - Create a node for each project and recursively add its parent folders as nodes\n * - If a project is added where a folder exists already, overwrite the folder node\n * - In the end, if a folder with the '.' root exists, it will be the singular root node\n */\n/* eslint-disable @typescript-eslint/no-non-null-assertion -- dealing with maps is hard */\nexport async function getProjectFolderTree(workspacePath: string): Promise<{\n  serializedTreeMap: { name: string; node: TreeNode }[];\n  roots: TreeNode[];\n}> {\n  const {\n    workspace: { projects },\n  } = await nxWorkspace(workspacePath);\n\n  const treeMap = new Map<string, TreeNode>();\n  const roots = new Set<TreeNode>();\n\n  function connectNodeToParent(node: TreeNode, parent: TreeNode) {\n    parent.children.push(node);\n  }\n\n  function addProjectOrFolderTreeNode(\n    dir: string,\n    projectName?: string,\n    projectConfiguration?: NxProjectConfiguration\n  ) {\n    // if a node is only a folder and exists already, we don't need to add it again\n    if (!projectConfiguration && !projectName && treeMap.has(dir)) {\n      return;\n    }\n\n    // if a node is a project and exists already, we need to replace the folder node with a new project node\n    if (projectConfiguration && projectName && treeMap.has(dir)) {\n      const oldNode = treeMap.get(dir)!;\n      treeMap.set(dir, {\n        dir,\n        projectName: projectName,\n        projectConfiguration,\n        children: oldNode.children,\n      });\n      return;\n    }\n\n    // if a node doesn't exist, we need to add it\n    const treeNode = {\n      dir,\n      projectName,\n      projectConfiguration,\n      children: [],\n    };\n    treeMap.set(dir, treeNode);\n\n    // after adding, we need to connect it to its parent or create it if it doesn't exist\n    // if there is no parent, the node is a root\n    const parentPath = parse(dir).dir;\n    if (!parentPath) {\n      roots.add(treeNode);\n      return;\n    }\n\n    if (treeMap.has(parentPath)) {\n      connectNodeToParent(treeMap.get(dir)!, treeMap.get(parentPath)!);\n    } else {\n      addProjectOrFolderTreeNode(parentPath);\n      connectNodeToParent(treeMap.get(dir)!, treeMap.get(parentPath)!);\n    }\n  }\n\n  for (const [projectName, projectDef] of Object.entries(projects)) {\n    addProjectOrFolderTreeNode(projectDef.root, projectName, projectDef);\n  }\n\n  // special case: if there is a '.' project, it will be the singular root\n  if (treeMap.has('.')) {\n    const workspaceRootProjectNode = treeMap.get('.');\n    roots.forEach((root) => {\n      if (root.projectConfiguration?.root === '.') {\n        return;\n      }\n      workspaceRootProjectNode?.children.push(root);\n    });\n    roots.clear();\n    roots.add(workspaceRootProjectNode!);\n  }\n  const serializedTreeMap = Array.from(treeMap.entries()).map(\n    ([name, node]) => ({\n      name,\n      node,\n    })\n  );\n  const sortedRoots = Array.from(roots).sort((a, b) => {\n    return a.dir.localeCompare(b.dir);\n  });\n  return { serializedTreeMap, roots: sortedRoots };\n}\n","import { execSync } from 'child_process';\nimport { nxWorkspace } from './workspace';\nimport { getNxExecutionCommand } from '@nx-console/shared/utils';\nimport { Logger } from '@nx-console/shared/schema';\n\nexport async function hasAffectedProjects(\n  workspacePath: string,\n  _: Logger\n): Promise<boolean> {\n  const { isEncapsulatedNx } = await nxWorkspace(workspacePath);\n\n  const command = getNxExecutionCommand({\n    cwd: workspacePath,\n    displayCommand: `nx show projects --affected`,\n    encapsulatedNx: isEncapsulatedNx,\n  });\n  const output = execSync(command, {\n    cwd: workspacePath,\n    windowsHide: true,\n    stdio: 'pipe',\n  });\n\n  return output.toString().trim().length > 0;\n}\n"],"names":["leafPrototypes","getProto","webpackEmptyContext","req","e","Error","code","keys","resolve","id","module","exports","webpackEmptyAsyncContext","Promise","then","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","Object","getPrototypeOf","obj","t","value","mode","this","ns","create","r","def","current","indexOf","getOwnPropertyNames","forEach","key","definition","o","defineProperty","enumerable","get","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","log","lspLogger","message","args","Date","now","toISOString","languageService","getJsonLanguageService","getSchemaRequestService","handledSchemas","builtInHandlers","protocol","getContent","location","encoding","c","uri","URI","parse","fs","fsPath","err","buf","toString","_encoding","xhr","url","followRedirects","headers","response","responseText","error","reject","getErrorStatusDescription","status","substr","builtInHandler","sortWorkspaceProjects","w","sortedProjects","entries","projects","sort","projectA","projectB","localeCompare","fromEntries","hasKey","formatError","stack","async","fileExists","filePath","stat","isFile","_unused","zipOpenFs","ZipOpenFS","libzip","crossFs","PosixFS","fileContents","clearJsonCache","basedir","fullFilePath","path","readAndCacheJsonFile","json","startsWith","replace","stats","statPromise","_fullFilePath","content","readFilePromise","JSON","errors","result","parseJson","length","offset","readAndParseJson","directoryExists","isDirectory","packageDetails","packagePath","join","packageName","name","packageJson","PNP_API","getPnpFile","workspacePath","extensions","ext","fileName","pnpFile","pnpApi","pnp","setup","isWorkspaceInPnp","_unused2","pnpDependencyPath","dependencyName","_pnp$resolveToUnquali","resolveToUnqualified","_pnp$resolveVirtual","includes","resolveVirtual","_unused3","workspaceDependencies","nxVersion","dependencies","push","version","major","packages","values","map","project","root","existingPackages","pkg","localDependencies","resolveRequest","locator","getDependencyTreeRoots","getPackageInformation","packageDependencies","reference","_pkg$packageDependenc","Array","isArray","pnpDependencies","nodeModules","nodeModulesEncapsulated","nodeModulesDir","res","dirContents","readdir","npmPackageOrScope","p","npmDependencies","workspaceDependencyPath","workspaceDependencyName","nodeModulesPath","encapsulatedPath","findNxPackagePath","buildPath","base","nxWorkspaceDepPath","nrwlWorkspaceDepPath","getNxExecutionCommand","config","command","displayCommand","encapsulatedNx","platform","packageManager","detectPackageManager","cwd","packageManagerCommand","getPackageManagerCommand","exec","getNxDaemonClient","logger","getNxPackage","getNxOutput","importPath","getNxProjectGraphUtils","getNxProjectGraph","getNxWorkspacePackageFileUtils","imported","getNxWorkspaceConfig","sourceMaps","projectGraph","start","performance","readWorkspaceConfigs","process","env","CI","NX_PROJECT_GLOB_CACHE","NX_WORKSPACE_ROOT_PATH","nxWorkspacePackage","nxProjectGraph","nxOutput","nxProjectGraphUtils","nxDaemonClientModule","all","workspaceConfiguration","gte","full","readWorkspaceConfig","format","exit","console","warn","output","createProjectGraph","projectGraphAndSourceMaps","createProjectGraphAndSourceMapsAsync","exitOnError","createProjectGraphAsync","projectFileMap","_await$nxProjectGraph","_projectGraph$nodes","_projectGraph","_nxDaemonClientModule","createProjectFileMapUsingProjectGraph","nodes","projectName","_files","_projectGraph2","data","files","modifiedWorkspaceConfiguration","assign","node","workspaceProject","_node$data$targets2","targets","_node$data$targets","_node$data$tags","match","tags","createNxWorkspaceConfiguration","daemonClient","reset","end","_projects","workspaceJson","nxJson","configPath","nxWorkspacePackageJson","loadedNxPackage","defaultSemver","SemVer","getNxVersion","minor","coerce","Status","cachedReplay","ReplaySubject","not_started","nxWorkspace","resetStatus","firstValueFrom","iif","of","pipe","tap","in_progress","switchMap","from","_config$workspaceConf","_config$workspaceConf2","isLerna","validWorkspaceJson","workspace","daemonEnabled","isEncapsulatedNx","installation","workspaceLayout","appsDir","libsDir","_workspace","next","cached","GeneratorType","_rootProjectMap","isProjectOption","option","_option$$default","$default","$source","readCollections","options","clearPackageJsonCache","collections","allCollections","readCollection","flat","dedupedCollections","Map","singleCollection","has","collectionNameWithType","type","set","executorCollections","generatorCollections","executors","builders","generators","schematics","getCollectionInfo","collectionName","collectionPath","executorCollection","generatorCollection","collectionMap","schema","canUse","includeHidden","includeNgAdd","collectionInfo","schemaPath","formatCollectionPath","implementationPath","implementation","formatPath","readCollectionGenerator","extends","extendedSchema","extendedCollections","filter","extended","dependencyPath","Boolean","collection","collectionSchemaName","collectionJson","_collectionJson$alias","generatorType","Application","Library","Other","description","aliases","s","includeHiddenCollections","includeNgAddCollection","hidden","private","jsonFilePath","dirname","getExecutors","getProjectByPath","normalize","sep","substring","projectsMap","getProjectsByPaths","getProjectByRoot","rootPath","_rootProjectMap2","rootProjectMap","projectEntries","projectConfig","paths","pathsNormalized","pathsMap","relative","relativePath","foundProjects","_projectConfig$files","_","foundProject","findByFilePath","delete","isChildOfRoot","isChildOrEqual","relativeRootConfig","sourceRoot","isChildOfRootConfig","nonDirectoryPaths","file","size","entry","selectedPath","_perfectMatchEntry","perfectMatchEntry","secondaryMatchEntry","projectConfiguration","fullProjectPath","isAbsolute","parent","child","endsWith","createBuildersAndExecutorsSchema","reduce","acc","schemaRef","if","properties","builder","const","required","$ref","configurations","additionalProperties","executor","X_COMPLETION_TYPE","X_COMPLETION_GLOB","CompletionType","hasCompletionType","hasCompletionGlob","implicitDependencies","items","outputs","directory","inputs","inputNameWithDeps","input","inputName","fileset","runtime","namedInputs","oneOf","enum","dependsOn","targetsWithDeps","target","params","allOf","getProjectJsonSchema","targetDefaults","contents","_ref","targetsSchema","targetsProperties","defaults","targetSchema","find","_test$properties","test","else","createJsonSchema","getPackageJsonSchema","nx","ignore","getNxJsonSchema","Set","_projectConfiguration","add","getTargets","projectTargets","tasksRunnerOptions","cacheableOperations","targetDependencyConfig","currentExecutors","currentNxWorkspace","currentBaseSchemas","configureSchemas","workingPath","workspaceContext","capabilities","workspaceJsonSchema","title","architect","getWorkspaceJsonSchema","projectJsonSchema","packageJsonSchema","nxSchema","fileMatch","projectSchemas","projectSchema","getProjectSchema","_configureJsonLanguageService","getProjectSchemas","projectSchemaIsRegistered","projectRoot","configureSchemaForProject","projectRootPath","_project$targets","_target$executor","_currentExecutors","matchingCollection","baseSchemas","settings","schemaRequestService","contributions","clientCapabilities","schemas","getLanguageService","configure","isPropertyNode","isObjectNode","isStringNode","isArrayNode","defaultCompletionMap","getDefaultCompletionType","keyNode","toLowerCase","hasDefaultCompletionType","createCompletionItem","label","document","kind","documentation","insertText","insertTextFormat","textEdit","newText","range","positionAt","detail","inputNameCompletion","hasDependencyHat","_workspace$namedInput","CompletionItemKind","Property","findProjectRoot","children","_child$valueNode","valueNode","glob","completionType","projectTarget","pathCompletion","supportsInterpolation","searchType","fastGlob","dot","onlyFiles","onlyDirectories","objectMode","completionKind","Folder","File","tagsCompletion","tagCompletion","tag","existingTags","item","getTagsOnCurrentNode","Constant","targetsCompletion","targetNames","targetName","existingTargets","getTargetsOnCurrentNode","dependencyHat","Field","getCompletionItems","jsonAst","position","offsetAt","getNodeFromOffset","completion","projectTargetCompletion","completionItemKind","configuration","_configuration$target","targetLabel","_target$configuration","configurationLabel","projectCompletion","Struct","completionItems","resolvedItems","schemaNode","defaultCompletion","existingItems","i","stringify","resolvedItem","isExecutorStringNode","createRange","endPosition","Range","_getJsonLanguageServi","parseJSONDocument","languageModels","maxEntries","cleanupInterval","nModels","getLanguageModelCache","retrieve","stripSchema","languageId","languageModelInfo","cTime","languageModel","TextDocument","getText","oldestTime","Number","MAX_VALUE","oldestUri","onDocumentRemoved","dispose","clearInterval","findProperty","property","found","setInterval","cutoffTime","cleanupIntervalTimeInSec","uris","tempDocumentCounter","targetLink","targetString","parsedTargets","parseTargetString","baseTargetPath","baseTargetProjectPath","projectJson","readFile","versionNumber","_tempDocumentCounter$","targetNode","targetProperty","configurationNode","findTargetRange","scheme","fragment","line","getHover","hoverParams","hover","doHover","RegExp","isNxExecutorStringNode","constructExecutorUrl","executorName","split","NxChangeWorkspace","NotificationType","NxWorkspaceRefreshNotification","NxReset","NxWorkspaceRequest","RequestType","NxWorkspacePathRequest","NxGeneratorsRequest","NxGeneratorOptionsRequest","NxProjectByPathRequest","NxProjectsByPathsRequest","NxProjectByRootRequest","NxGeneratorContextFromPathRequest","NxGeneratorContextV2Request","NxVersionRequest","NxProjectGraphOutputRequest","NxCreateProjectGraphRequest","NxProjectFolderTreeRequest","NxTransformedGeneratorSchemaRequest","NxStartupMessageRequest","NxHasAffectedProjectsRequest","NxSourceMapFilesToProjectMapRequest","NxTargetsForConfigFileRequest","NX_PLUGIN_PATTERNS_TO_WATCH","languageServerWatcher","callback","debouncedCallback","wait","timerId","clearTimeout","setTimeout","debounce","watcher","Watcher","watch","events","some","pattern","minimatch","stop","subscription","getIgnoredGlobs","backend","watcherOptions","unsubscribe","listFiles","dirName","readdirSync","statSync","normalizeSchema","projectDefaults","cliOptions","currentProperty","$defaultIndex","positional","visible","_property$visible","isPropertyVisible","originalName","requiredFields","nxOptions","_option$originalName","xPrompt","workspaceDefault","nxOption","isRequired","isFieldRequired","alias","default","getItems","tooltip","isLongFormXPrompt","itemTooltips","enumTooltips","isOptionItemLabelValue","getEnumTooltips","optionComparator","compareOptions","legacyCompareOptions","b","getPrio","opt","aPrio","bPrio","IMPORTANT_FIELD_NAMES","IMPORTANT_FIELDS_SET","checkAndReadWorkspaceGenerators","workspaceGeneratorType","workspaceGeneratorsPath","collectionDir","f","basename","_schemaJson$json$xTy","_schemaJson$json$desc","schemaJson","schemaJsonPath","$id","readWorkspaceGeneratorsCollection","getGeneratorOptions","generatorName","generatorPath","generatorSchema","workspaceDefaults","collectionDefaults","collectionDefaultsMap","_defaults","_defaults$collectionN","_defaults2","_defaults3","readWorkspaceJsonDefaults","getGeneratorContextV2","normalizedDirectory","normalizedPath","getDirectory","dir","getDirectoryWithoutAppsDirLibsDir","_dir","existsSync","lstatSync","getProjectGraphOutput","cacheDir","getCacheDir","fullPath","internalPlugins","schemaProcessors","projectNameAndRootProcessor","_schema$options","_workspace$workspace$","_schema$options$find","_schema$context$prefi2","_schema$context2","_schema$context$prefi","_schema$context","projectNameAndRootFormat","context","prefillValues","pnarfDefault","prefillProjectAndDirProcessor","_schema$context3","_schema$context$prefi3","prefillProject","prefillDirectoryAsCwd","every","_schema$context4","_schema$context5","_schema$context7","_schema$context8","_schema$context6","_schema$context9","_schema$context$prefi4","nameAndDirectoryProcessor","nadfDefault","nameAndDirectoryFormat","addProjectItemsToOptionProcessor","validators","startupMessageFactories","promisify","windowsHide","projectNameAndRootStartupMessage","_schema$options2","_workspace$workspace$2","nameAndDirectoryStartupMessage","loadPlugins","_internalPlugins$sche","_workspacePlugins$sch","_workspacePlugins","_internalPlugins$vali","_workspacePlugins$val","_workspacePlugins2","_internalPlugins$star","_workspacePlugins$sta","_workspacePlugins3","workspacePlugins","pluginFile","_sourceMapFilesToProjectMap","WORKING_PATH","CLIENT_CAPABILITIES","on","connection","unregisterFileWatcher","reconfigureAttempts","resolveRelativePath","resource","lastIndexOf","Utils","resolvePath","createConnection","ProposedFeatures","documents","TextDocuments","listen","onInitialize","_params$initializatio","bind","setLspLogger","initializationOptions","_params$workspaceFold","_params$rootUri","workspaceFolders","rootUri","reconfigureAndSendNotificationWithBackoff","textDocumentSync","TextDocumentSyncKind","Incremental","completionProvider","resolveProvider","triggerCharacters","hoverProvider","definitionProvider","documentLinkProvider","workDoneProgress","fileOperations","didCreate","filters","matches","FileOperationPatternKind","didDelete","onCompletion","_await$getJsonLanguag","_getJsonLanguageServi2","ResponseError","changedDocument","completionParams","textDocument","getJsonDocument","relativeRootPath","completionResults","doComplete","CompletionList","getMatchingSchemas","pathItems","arr1","arr2","apply","onHover","hoverDocument","onDefinition","definitionParams","definitionDocument","executorFile","resolveImplementation","LocationLink","character","getDefinition","onDocumentLinks","_getJsonLanguageServi3","linkDocument","links","linkType","_getDefaultCompletion","DocumentLink","link","getDocumentLinks","jsonDocumentMapper","reconfigure","sendNotification","method","resetNxVersionCache","onDidClose","onDidOpen","onShutdown","onNotification","packageManagerCommands","rej","nxReset","onRequest","getGenerators","projectPath","generator","_generator$options","modifiedPath","getGeneratorContextFromPath","showAffected","projectGraphOutput","execSync","stdio","treeMap","roots","connectNodeToParent","addProjectOrFolderTreeNode","oldNode","treeNode","parentPath","projectDef","workspaceRootProjectNode","_root$projectConfigur","clear","serializedTreeMap","getProjectFolderTree","plugins","modifiedSchema","_plugins$schemaProces","processor","getTransformedGeneratorSchema","startupMessageDefinition","factory","_plugins$startupMessa","getStartupMessage","trim","hasAffectedProjects","_workspace$sourceMaps","sourceMapFilesToProjectMap","sourceMap","getSourceMapFilesToProjectMap","configFilePath","getTargetsForConfigFile","createdFiles","deletedFiles"],"sourceRoot":""}